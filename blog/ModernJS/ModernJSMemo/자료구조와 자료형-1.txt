1. 원시값 vs 객체값
원시값이 객체처럼 프로퍼티나 메서드를 사용할 수 있지만 그럼에도 객체는 아니다.

원시값과 객체값의 차이점은 원시값은 7가지 (string, numberm boolean, symbol, null, undefined, bigInt);
객체값은 1가지(Object, 객체내에 함수가 존재한다.)이다. 원시값은 하나의 데이터 타입만 변수에 저장할 수 있고 객체값은 여러개의 데이터 타입을 변수에 저장할 수 있다.

원시값을 다룰 때 프로퍼티나 메서드를 사용하게 하면 효율적인 작업이 가능하다. 
이를 위해서 원시값은 그대로 남겨두고 문자열, 심볼, 불린, 숫자의 프로퍼티 접근이 가능하게 한다. 이를 가능하게 하기위해서 원시값에 대한 프로퍼티나 메서드에 접근하려고 하면 임시적으로 원시 래퍼 객체를 만들어주고 프로퍼티나 메서드를 사용하면 사라지게 한다. => 래퍼 객체

래퍼 객체 => String, Number, Boolean, Symbol 그대로 부른다.

new를 붙이는 것은 객체를 만든다는 뜻이다. new를 붙이지 않고 래퍼 객체를 사용하면 단순한 형변환이다.


2. 숫자형
int와 bigInt가 존재한다.

JS에서 0의 개수를 나태낼 떄는 e를 붙이고 그 옆에 숫자를 붙여도 된다. 양수는 e, 음수는 e-

number의 toString은 숫자를 단순 문자열로 바꿔준다.
number의 toFixed() =>인자는 소수점을 얼마나 취할 것이냐 물어보는 것, 이후 문자열로 반환한다.
JS는 숫자의 크기가 크면 64비트 공간이 넘쳐서 infinity로 처리된다. => 정밀도 손상

toString() => 숫자를 문자로 바꿔주는 메서드
toFixed() => 숫자의 소수점을 정하고 문자열로 반환하는 메서드

Math
수학 관련 JS 빌트인 객체
Math.floor() => 소수점 첫쨰 자리에서 내림
Math.ceil() => 소수점 첫쨰 자리에서 올림
Math.round() => 소수점 첫쨰 자리에서 반올림
Math.trunc() => 소수점을 무시한다.
Math.random() => 0과 1사이 난수를 반환한다.
Math.max()/min() => 인수 중 최대값과 최소값을 반환한다.
Math.pow(n,power) => n을 power번 거듭제곱한 값을 반환한다. 

isNaN vs isFinite
Infinity => 숫자의 크기가 너무 적거나 너무 크거나 할 떄 나타나는 숫자 값
NaN => 에러를 나타내는 값

isNaN() => 인수를 숫자로 변환한 다음 NaN인지 확인하는 함수
NaN은 null을 제외한 모든 타입과 비교할 때 false가 반환된다.
isFinity() => 인수를 숫자로 변환하고 변환한 숫자가 NaN이나 infinity가 아닌 일반 숫자일 경우 true를 반환한다.

parseInt vs parseFloat
다른 타입의 값과 숫자가 합쳐져 있는 경우 숫자만 뺴오는 메서드들이다.
두 함수는 불가능할 때까지 문자열에서 숫자를 ‘읽는다.’. 숫자를 읽는 도중 오류가 발생하면 이미 수집된 숫자를 반환한다.
parseInt는 정수, parseFloat는 부동 소수점 숫자를 반환한다.
=> 읽을 수 없다면 둘 다 NaN을 반환한다.
=> "--숫자--", 앞에 문자가 있다면 parseInt나 parseFloat는 NaN을 반환한다. 뒤에 문자가 있다면 무시한다.


4. 문자열
템플릿 리터럴 => ${} 표현식을 넣을 수 있다.
역슬래시 => JS 문법의 문자들을 일반 문자열로 표현하기 위해 사용된다.
문자열은 유사배열객체이면서 iteable한 객체이기 때문에 length나 for-of를 사용할 수 있다.

문자열 메서드
substring() => 인자x 라면 전체 복사, 인자가 하나라면 해당 인덱스부터 전체복사, 인자가 두개라면 해당 인덱스부터 해당 길이까지 가져온다.
slice() => 음수로직 substring();


3. 배열
배열은 순서가 키이다. 

for-of
for-of를 사용하면 현재 요소의 인덱스는 얻을 수 없고 값만 얻을 수 있다.

for-in
=> 모든 프로퍼티를 대상으로 순회한다. 키가 숫자가 아닌 프로퍼티도 순회대상이다.
=> 배열에 사용하면 for-of를 사용하는 것보다 성능이 많이 떨어진다.
=> 키를 반환한다.




































