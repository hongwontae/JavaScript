1. 객체

원시값은 하나의 데이터 타입을 담을 수 있다. 객체형은 여러 데이터 타입을 담을 수 있다.

객체는 키는 문자열만 가능하고 값은 모든 데이터 타입이 가능하다.

객체는 만드는 방법
1. let a = {name : hwt}; => 객체 리터럴
2. let a1 = new Objec(); => 생성자 함수

const로 만든 객체는 수정가능하다. => 객체는 주소값을 저장하고 있기에 값을 수정하는 것은 const의 상수값에 영향을 주는 것이 아니다.

객체의 키를 특별하게 만들고 싶다면 대괄호 표기법을 사용하여 나타내면 된다.

단축 프로퍼티 => 객체의 키와 값의 이름이 동일하면 한 개만 적어도 된다.

존재하지 않는 프로퍼티에 접근하면 undefined가 반환된다.

in 연산자 => 객체의 키 값을 확인할 수 있는 연산자이다.
console.log('age' in person) => person이라는 객체에 age의 키를 가진 프로퍼티가 존재하는가> true or false

for-in 반복문 => 객체의 키값을 가져오는 반복문이다.

객체 정렬 방식
정수 프로퍼티는 내림차순, 그 외의 프로퍼티는 객체를 추가한 순서부터 정렬된다.
정수 프로퍼티 : 정수로 변환하거나 문자열로 변환하거나 해도 값의 변경은 없는 프로퍼티를 의미한다.
"49"를 숫자로 바꿔도 문자로 바꿔도 49이다.
+단항 연산자, 소수는 정수 프로퍼티가 아니다.



2. 참조에 의한 객체 복사
원시값의 복사는 값의 복사이고 참조값의 복사는 주소값의 복사이다.
객체가 할당된 변수를 복사하여 대입할 떄 객체의 참조값이 복사되고 객체 자체가 복사되는 것이 아니다.

for-in 반복문은 새로운 객체를 만들어낸다.

Object.assign(dest, src1, src2, src3....)
=> 독립적인 객체를 복사하는 메서드이다.
=> dest는 목표로 하는 객체이다. src1~srcN은 객체 이름이고 값만 가져온다.
=> 이후 desk이름으로 반환한다.

얕은 복사 => 중첩 객체는 동일한 주소값을 갖는다.
깊은 복사 => 중첩 객체일지라도 동일한 주소값을 갖지 않는다.



3. 메서드와 this
객체안의 함수 => 메서드라고 부른다.

메서드의 this는 호출한 객체를 참조한다.
화살표 함수의 this는 자신만의 this를 가지지 않고 외부의 this 값을 가져온다.



4. New 연산자와 생성자 함수
생성자 함수를 통해서 객체를 만든다.  => new를 사용한다.

생성자 함수 관례 
1. 함수 이름의 첫 글자는 대문자이다.
2. 반드시 New 연산자를 붙여서 실행한다.

New Algorithm
1. 빈 객체를 만들어 this에 할당한다. this = {};
2. 함수 본문을 실행한다. this에 새로운 프로퍼티를 추가해 this 객체를 수정한다.
3. this를 반환한다.

생성자 함수의 목적 => 재사용성

New의 로직 때문에 return할 필요가 없다. but return을 사용한다면?
1. 객체를 return하면 this대신 해당 객체가 반환된다.
2. 원시값을 리턴하면 return문이 무시된다.

생성자에서 메서드를 구현할 수 있다.



5. 옵셔널 체이닝 ?.
?. 앞의 평가 대상이 null이나 undefined면 평가를 멈추고 undefined를 반환한다.
?.은 왼쪽 평가대상에 값이 없으면 즉시 평가를 멈춘다. 이러한 평가방법를 단락 평가라고 한다.

?.은 연산자가 아니다. 객체의 접근이나 메서드나 대괄호와 함께 동작하는 문법 구조체이다.
delete user?.name => user가 존재하면 user.name을 삭제한다.

대략적으로 3가지 방식으로 사용한다.
1. obj?.prop – obj가 존재하면 obj.prop을 반환하고, 그렇지 않으면 undefined를 반환함
2. obj?.[prop] – obj가 존재하면 obj[prop]을 반환하고, 그렇지 않으면 undefined를 반환함
3. obj?.method() – obj가 존재하면 obj.method()를 호출하고, 그렇지 않으면 undefined를 반환함
































