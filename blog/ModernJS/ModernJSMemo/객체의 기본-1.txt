1. 객체

원시값은 하나의 데이터 타입을 담을 수 있다. 객체형은 여러 데이터 타입을 담을 수 있다.

객체는 키는 문자열만 가능하고 값은 모든 데이터 타입이 가능하다.

객체는 만드는 방법
1. let a = {name : hwt}; => 객체 리터럴
2. let a1 = new Objec(); => 생성자 함수

const로 만든 객체는 수정가능하다. => 객체는 주소값을 저장하고 있기에 값을 수정하는 것은 const의 상수값에 영향을 주는 것이 아니다.

객체의 키를 특별하게 만들고 싶다면 대괄호 표기법을 사용하여 나타내면 된다.

단축 프로퍼티 => 객체의 키와 값의 이름이 동일하면 한 개만 적어도 된다.

존재하지 않는 프로퍼티에 접근하면 undefined가 반환된다.

in 연산자 => 객체의 키 값을 확인할 수 있는 연산자이다.
console.log('age' in person) => person이라는 객체에 age의 키를 가진 프로퍼티가 존재하는가> true or false

for-in 반복문 => 객체의 키값을 가져오는 반복문이다.

객체에 프로퍼티가 존재하지 않는데 접근하면 undefined가 반환된다.

객체 정렬 방식
정수 프로퍼티는 내림차순, 그 외의 프로퍼티는 객체를 추가한 순서부터 정렬된다.
정수 프로퍼티 : 정수로 변환하거나 문자열로 변환하거나 해도 값의 변경은 없는 프로퍼티를 의미한다.
"49"를 숫자로 바꿔도 문자로 바꿔도 49이다.
+단항 연산자, 소수는 정수 프로퍼티가 아니다.



2. 참조에 의한 객체 복사
원시값의 복사는 값의 복사이고 참조값의 복사는 주소값의 복사이다.
객체가 할당된 변수를 복사하여 대입할 떄 객체의 참조값이 복사되고 객체 자체가 복사되는 것이 아니다.

for-in 반복문은 새로운 객체를 만들어낸다.

Object.assign(dest, src1, src2, src3....)
=> 독립적인 객체를 복사하는 메서드이다.
=> dest는 목표로 하는 객체이다. src1~srcN은 객체 이름이고 값만 가져온다.
=> 이후 desk이름으로 반환한다.

얕은 복사 => 중첩 객체는 동일한 주소값을 갖는다.
깊은 복사 => 중첩 객체일지라도 동일한 주소값을 갖지 않는다.



3. 메서드와 this
객체안의 함수 => 메서드라고 부른다.

메서드의 this는 호출한 객체를 참조한다.
화살표 함수의 this는 자신만의 this를 가지지 않고 외부의 this 값을 가져온다.



4. New 연산자와 생성자 함수
생성자 함수를 통해서 객체를 만든다.  => new를 사용한다.

생성자 함수 관례 
1. 함수 이름의 첫 글자는 대문자이다.
2. 반드시 New 연산자를 붙여서 실행한다.

New Algorithm
1. 빈 객체를 만들어 this에 할당한다. this = {};
2. 함수 본문을 실행한다. this에 새로운 프로퍼티를 추가해 this 객체를 수정한다.
3. this를 반환한다.

생성자 함수의 목적 => 재사용성

New의 로직 때문에 return할 필요가 없다. but return을 사용한다면?
1. 객체를 return하면 this대신 해당 객체가 반환된다.
2. 원시값을 리턴하면 return문이 무시된다.

생성자에서 메서드를 구현할 수 있다.


5. 옵셔널 체이닝 ?.
?. 앞의 평가 대상이 null이나 undefined면 평가를 멈추고 undefined를 반환한다.
?.은 왼쪽 평가대상에 값이 없으면 즉시 평가를 멈춘다. 이러한 평가방법를 단락 평가라고 한다.

?.은 연산자가 아니다. 객체의 접근이나 메서드나 대괄호와 함께 동작하는 문법 구조체이다.
delete user?.name => user가 존재하면 user.name을 삭제한다.

대략적으로 3가지 방식으로 사용한다.
1. obj?.prop – obj가 존재하면 obj.prop을 반환하고, 그렇지 않으면 undefined를 반환함
2. obj?.[prop] – obj가 존재하면 obj[prop]을 반환하고, 그렇지 않으면 undefined를 반환함
3. obj?.method() – obj가 존재하면 obj.method()를 호출하고, 그렇지 않으면 undefined를 반환함


6. 객체를 원시형으로 변환하기
객체끼리 연산을 하는 경우 자동 형변환(원시값으로 변환)되어 계산된다.

hint => 목표로 하는 자료형

alert같이 문자열을 기대하는 함수나 무엇가를 출력하는 함수에서 객체는 string이 된다.
수학 연산을 적용할려 할 떄는 hint가 number가 된다.
연산자가 기대하는 자료형이 확실하지 않을 때는 default가 된다.


6. 심볼형
JS는 객체 프로퍼티 키로 오직 문자형과 심볼형만 허용한다.

심볼은 유일한 식별자를 만들고 싶을 떄 사용한다.
Symbol()을 사용하면 심볼값을 만들 수 있다. 
ex)
let id = Symbol();
let id = Symbol("id"); => 설명을 붙이는 것이다.

심볼은 유일성이 보장되는 자료형이다. 설명이 동일해도 각 심볼값은 다르다. 심볼에 붙이는 설명은 어떤 것에도 영향을 주지 않는다. 단지 이름표 역할만 한다.

** 심볼값은 다른 자료형을 암시적 형 변환이 되지 않는다. 심볼을 출력해야 하는 상황이면 .toString을 사용하면 된다.

심볼을 이용하면 숨김 프로퍼티를 만들 수 있다. 숨김 프로퍼티는 외부 코드에서 접근이 불가능하고 값도 덮어쓸 수 없는 프로퍼티이다. = user라는 객체에 키 값이 id라면 충돌할 가능성이 높다. (오버라이딩) 만약 심볼값으로 하면 유일하기 때문에 충돌 가능성이 없다.


심볼형을 객체의 키값에 부여하는 두 가지 방법 => Symbol.js

for-in에서 심볼은 제외된다.
Object.Keys(); => 인자에 객체를 넣으면 반환값으로 배열안의 키가 반환된다. => 심볼은 제외된다.


전역 심볼
이름이 같은 심볼이 같은 개체를 가리키길 원하는 경우가 존재한다. => 전역 심볼 레지스트리를 이용한다.
전역 심볼 레지스트리 안에 심볼을 만들고 해당 심볼에 접근하면 이름이 같은 경우 항상 동일한 심볼을 반환한다.

레지스트리 안에 있는 심볼을 읽거나, 새로운 심볼을 생성하려면 Symbol.for(key)를 사용하면 된다.
이 메서드를 호출하면 이름이 key인 심볼을 반환한다. 조건에 맞는 심볼이 레지스트리 안에 없으면 새로운 심볼 Symbol(key)을 만들고 레지스트리 안에 저장한다.

=> Symbol("..") ..은 단지 이름일 뿐이다. 이 이름을 일치하는 것을 찾는 것이고 없으면 만드는 것이다.


Symbol.keyFor()
=> 이 메서드를 사용하면 이름을 얻을 수 있다.
=> Symbol.keyFor는 전역 심볼 레지스트리를 뒤져서 해당 심볼의 이름을 얻어낸다. 검색 범위가 전역 심볼 레지스트리이기 때문에 전역 심볼이 아닌 심볼에는 사용할 수 없다. 전역 심볼이 아닌 인자가 넘어오면 Symbol.keyFor는 undefined를 반환한다.
=> 전역이 아닌 심볼은 description 프로퍼티로 찾는다.
























