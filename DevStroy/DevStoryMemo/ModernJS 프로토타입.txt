1.[[Prototype]]
JS객체는 [[Prototype]]라는 숨김 프로퍼티를 갖는다. 이 숨김 프로퍼티의 값은 null이거나 다른 객체에 대한 참조가 된는데, 다른 객체를 참조하는 경우 참조 대상을 프로토타입이라고 부른다.

객체에서 프로퍼티를 읽으려고 하는데 해당 프로퍼티가 없다면 프로토타입 프로퍼티를 찾는다. => 이를 프로토타입 상속이라고 부른다.

[[Prototype]] 프로퍼티는 내부 프로퍼티이면서 숨김 프로퍼티지만 개발자가 값을 설정할 수 있다.
=>__proto__를 사용하면 된다. (ModernJS Prototype1.js)
=> __proto__는 [[Prototype]]용 getter·setter인 것이다.

프로토타입에서 상속받은 프로퍼티를 상속 프로퍼티라고 부른다.


프로토 타입 체인
__proto__의 값은 객체나 null만 허용한다.
객체에는 오직 하나의 [[prototype]]만 존재해야 한다

데이터 프로퍼티 => 객체 프로퍼티를 의미한다.
접근자 프로퍼티 => getter,setter


프로토 타입은 읽기 전용이다.
=> 프로토타입은 프로퍼티를 읽을 때만 사용한다.프로퍼티를 추가, 수정하거나 지우는 연산은 객체에 직접 해야 한다.

ex) let animal = {
  eats: true,
  walk() {
    /* rabbit은 이제 이 메서드를 사용하지 않습니다. */
  }
};

let rabbit = {
  __proto__: animal
};

rabbit.walk = function() {
  alert("토끼가 깡충깡충 뜁니다.");
};

rabbit.walk(); // 토끼가 깡충깡충 뜁니다.

// => 프로토타입을 상속받은 객체에서 프로토타입을 수정하면 프로토타입을 수정하라는 로직으로 알아먹지 못한다.
// => 일반 walk 메서드를 생성하고 실행시 이를 우선적으로 실행한다.


this는 프로토타입에 영향을 받지 않는다. (Prototype2)
메서드를 객체에서 호출했든 프로토타입에서 호출했든 상관없이 this는 언제나 . 앞에 있는 객체이다.


for in
for..in은 상속 프로퍼티도 순회대상에 포함시킵니다.
=> for-in 반복문은 객체의 키와 프로토타입의 키도 같이 순회한다.

Object.keys() => 객체 자신의 키만 반환한다.
Object.hasOwnProperty() => 이 내장 메서드는 key에 대응하는 프로퍼티가 상속 프로퍼티가 아니고 obj에 직접 구현되어있는 프로퍼티일 때만 true를 반환한다.

프로토타입을 상속받은 객체(a)가 또 다른 객체(b)의 상속이 되면 b에게 a의 모든 객체를 주는 것이다. 

a객체 -> 프로토타입 상속 -> b 객체 -> 프로토타입상속 -> c 객체([[prototype]] a{}, b{})





















