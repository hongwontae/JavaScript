1. 객체란 무엇인가?
정의 : 다양한 자료형을 담을 수 있는 키-값으로 구성된 프로퍼티들의 집합이다.

특징
1-1. 중괄호에 프로퍼티 저장
1-2. 키에는 문자형만 가능, value로는 모든 자료형 가능


2. 객체 생성 방법
2-1. 객체 리터럴
=> let a = {name : 'hwt', age = 30}
2-2. 객체 생성자
=> let user = new Obejct({..})


3. 객체의 특징
3-1. dot 표기법으로 값을 가져온다.
3-2. 키에 숫자나 띄어쓰기, 기타 외를 사용하려면 쌍따옴표로 묶어서 사용해라
3-3. 대괄호 표기법 => 3-2로 작성한 키를 dot 표기법으로 그냥 가져올 수 없다. []를 사용하면 값에 접근가능
3-4. 단축 프로퍼티 => key와 value가 같다면 하나만 사용하고 콤마(,) 사용해도 된다.
3-5. in 연산자 => obj에 프로퍼티가 존재하는지 boolean으로 반환하는 연산자
3-6. for-in => 객체의 모든 키를 순회할 수 있다.


4. 객체 참조 복사
원시형은 콜스택 주소값과 대응되는 value는 불변하다. 이는 하나만 존재, 하나의 길만 존재한다는 것이다.
참조형은 같은 힙메모리를 공유한다. => 같은 주소값을 가지고 있다. 힙메모리를 공유한 변수들의 값의 변화는 다른 변수
에도 영향을 미친다는 뜻이다.

=> for-in을 사용하면 메모리 힙을 공유하지 않고 값을 전달해 줄 수 있다.
for(const key in obj){
    c2[key] = obj[key];
} => c2는 obj의 값을 전달받았지만 힙 메모리는 다름
=> 깊은 복사/ (얕은 복사는 합 메모리 주소값을 공유한다는 뜻)


5. Object.assign(obj, obj2, obj3...)
5-1. 첫 번쨰 나오는 값을 기준으로 이후의 인수의 프로퍼티만 가져와서 사용한다.
5-2. 동일한 이름을 가지면 오버라이딩한다.
5-3. let x = Object.assign()을 통해 할당도 가능


6. 가비지 컬렉터
=> 더 이상 사용하지 않는 변수들은 가비지 컬렉터에 의해 회수된다.


7. 메서드와 this
7-1. 메서드
=> 객체 내에서 정의한 함수
=> 단축 구문 존재 {hello(args..){body...}}

7-2. this
정의 : 메서드를 호출할 떄 사용된 객체를 나타낸다.

특징
1. this의 값은 런타임에 결정
2. 어떤 객체에서 호출되었는지가 this를 결정한다.
3. 객체가 없을 때 this => undefined
4. arrow-func의 this는 외부에서 this의 값을 가져온다.


8. new 연산자와 생성자 함수
생성자 함수 => 객체를 생성하는 함수

생성자 함수 rule
1. 함수의 이름 첫 글자는 대문자
2. new를 사용하여 함수를 호출한다.

new 생성자 Logic
1. 빈 객체를 만들어 this에 할당
2. 함수 본문을 실행, this에 새로운 프로퍼티를 추가해 this를 수정
3. this를 반환

생성자 함수 return
1. 생성자 함수내의 return은 거의 없다. this가 자동적으로 return 되기 떄문이다.
2. 명시적으로 return을 사용하면 => 객체일 경우 this 대신 객체가 반환되고 원시형일 경우 무시한다.


9. 옵셔널 체이닝 ?.
앞의 평가 대상이 undefined거나 null이면 평가를 멈추고 undefined를 반환한다.

?.은 연산자가 아니다. 
dot 표기법이나 대괄호 표기법을 사용할 떄 사용한다.




