1. PureFunction and sideEffect
순수 함수
=> 입력값이 있고 인자가 주어지면 늘 같은 값을 반환한다.
=> 아무런 부수 효과도 트리거 하지 않는다. 함수 외부에선 아무것도 바꾸지 않는다.

부수 효과
=> 함수의 외부를 바꿔놓는 것을 일컫는 용어이다. (HTTP 요청, DB데이터)
=> 함수의 밖에서 정의된 변수를 바꾸는 행위나 함수에 들어가는 객체나 배열을 바꾸는 행위 등...
=> 함수의 매개변수에 객체가 주어지면 배열의 복사본이 아니라 배열의 주소 복사본이 들어간다.

ex) let a = [1,2,3,4];
    function arrControl(a){
    a.push(5);
    console.log(a)
    }
    arrControl(a); => a [1,2,3,4,5]
=> 부수효과를 받은 비 순수 함수이다.


2. pure Function and none-pure Function
JS에서 sideEffect가 없는 순수 함수를 지향하는 것은 좋은 생각이다. => 이면에서 특수한 상황을 제외하여 이해하기 쉽다.

HTTP 통신이나 Data의 변경을 위한 함수를 사용하지 말라는 것이 아니다.

=> 최종적으로 지향해야하는 일은 최대한 순수함수를 만들고 사용하는 것이다.


3. 팩토리 Function
팩토리 함수는 또 다른 함수를 제공하는 함수이다.

함수내의 함수가 존재할 떄 반복작업을 회피하고 효율성있는 작업을 할 수 있게 해주는 함수 로직이다.
함수 내의 함수는 내부 함수의 외부에 있는 모든 것에 접근할 수 있다. => 상위 함수의 매개변수 tax에 접근할 수 있다.

function cal(a){
    function add(b){
        return a+b
    }
    return add;
}

const cal3 = cal(5);
const cal4 = cal(10);
console.log(cal3(15)); // 20
console.log(cal4(20)); // 30

=> 함수내의 매개변수를 지정해놓고 사용한다라고 이해하면 좋다.


4. closure
JS의 모든 함수는 클로저이다. => scope와 밀접한 연관이 있다.

1. 함수의 중괄호 내에서는 전역 변수에 접근할 수 있다.
2. 함수 내에서 변수를 만들면 외부에서 접근이 불가하다.
3. 함수 내의 함수는 외부 함수의 변수나 매개변수에 접근할 수 있다.
4. 외부함수는 안쪽 함수의 변수에 접근할 수 없다.

중첩 함수
1. JS는 함수 안에서 함수를 정의하는 것을 중첩함수라고 한다.
2. 내부 함수를 실행은 외부 함수에서만 가능하다. => 함수 반환이 아니다.
3. 내부 함수는 외부 함수의 매개변수나 변수에 접근할 수 있다.
ex) function name(name){
  function whatname(){
  console.log(name)
}
  whatname();
}

name('hwt'); => hwt

함수 반환 (중첩 함수이면서 함수반환이다.)
1. JS는 함수 안에 다른 함수를 반환 할 수 있다.
2. 외부 함수의 return으로 내부 함수를 넣는다. (실행x, 전달역할)
3. 실행하고 싶다면 일반적인 실행이 아니라 변수에 내부 함수의 return값을 넘기고 그 변수를 실행시켜야 제대로 작동한다.
ex) function showInfo(a){
   function inside(b){
  console.log(a+b)
}
  return inside;
}

const func = showInfo(10); => showInfo()의 반환값은? inside 함수 그 자체
func() = inside();
func(20) => 30이 반환된다.


클로저
JS는 외부 함수가 닫힌 후에도 내부 함수가 외부 범위에 접근하는 개념이다.


5. 클로저 실습
변수가 변경되면 항상 함수는 그 변수를 반영한다. 
=> 함수에서 변수에 접근할 떄 값에 접근하는 것이 아니라 변수 그 자체에 접근한다고 할 수 있다. 항상 찾을 수 있는 최신의 값을 찾는다.

=> 함수가 호출될 떄 가장 최신의 값을 찾는다.

함수의 변수를 찾을 떄는 내부 환경을 우선적으로 찾고 없다면 전역을 찾아서 사용한다.

scope == lexical enviorment

** 함수는 주변 환경과 변수에 접근하여 함수가 호출되었을 떄 이를 기억하고 사용할 수 있다. 그 변수가 곧바로 사용되지 않았더라도.. => 함수는 주변 변수를 기억한다. => 클로저의 개념중 일부







































