1. 성능 최적화란 무엇인가?
성능은 두 가지 맥락에서 생각할 수 있다. 하나는 웹 애플리케이션의 Start Time, 다른 하나는 런타임 성능이다.

웹 애플리케이션의 Start Time
=> 웹 페이지에 접속 후 렌더링되는 시간
=> 사용자가 페이지와 상호 작용할 수 있는 속도

Runtime Performance
=> 애니메이션 효과가 많을 경우 성능저하
=> 메모리 누수가 많을 경우 브라우저 성능저하

CSS가 복잡한 경우 적용하는 시간이 길어져서 성능이 저하되고 HTML이 복잡하면 초기 다운이 느려져 시작 시간이 길어진다.

애플리케이션이 크거나 애플리케이션을 사용하는 사용자가 많아지면 성능저하가 온다.

많은 것들이 성능에 관여하지만 JS의 성능 개선만을 생각했을 떄 
1. Startup Time
=> 스크립트의 다운과 실행에 관한 성능
이 경우 서버에 script가 존재하기 떄문에 큰 영향을 받지 않는다.

2. Rumtime Performance
=> js 코드 작동에 관한 성능
=> 메모리에 관한 성능 (DOM를 많이 조작하면 성능이 떨어진다.)


2. 최적화 가능성
성능에 관해서는 크게 두 가지 계층이 존재한다. 시작 시간과 런타임이다. (사용자가 페이지를 보기 위해 요청하고 서버에서 응답하여 사용자의 눈에 페이지가 뜨는 시간, 런타임은 js가 동작할 떄의 시간)

시작시간 성능
=> 스크립트의 크기
=> HTTP 통신은 크기와 상관없이 기본적으로 자연되는 시간이 있기 떄문에 많은 http 통신은 성능 저하를 일으킨다.
webpack를 통해 http 통신을 축소했다.

런타임 성능
=> 코드 실행에 관련한 최적화를 해야한다. 이떄 중요한 점은 DOM 조작 코드를 단순화시켜야 한다. 
=> 메모리 누수가 많아지면 성능이 저하되고 브라우저가 다운될 수 도 있다.
=> 기존 코드를 고수하는 것보다 성능이 개선된 코드를 사용해도 된다.

JS 뿐만 아니라 HTML, CSS의 크기나 복잡성도 애플리케이션 성능에 관여한다.


3. 성능 측정하기
웹 에플리케이션의 성능 최적화를 위해서 바로 코드에 들어가는 것이 아니라 성능 병목 현상(bottleneck)을 찾아야 한다. 
1. 얼마나 많은 http 통신이 있는지, 스크립트 크기가 어떠한지를 알아야 한다.
2. 브라우저 개발 도구로 런타임 성능을 측정할 수 있다. => 스크립트 특정 기능의 성능을 파악할 수 있다.
3. Internet 성능 개선을 벤치마킹하는 것도 방법이다.
4. 성능을 비교할 떄는 배포가 준비된 코드롤 성능을 측정해야 한다. 개발 코드는 성능을 고려한 코드도 아니기 때문이다.
5. performance.now()를 통해 작업이 얼마나 오래 걸리는지 알 수 있게 해준다.
6. jsperf.com, webpagetest.com를 통해 성능 개선의 도움을 받을 수 있다.


4. 성능 측정을 위한 브라우저 개발자 도구 파헤치기
DOM과 상호 작용하는 빈도와 DOM에서 영향을 주는 항목을 확인할 수 있는 도구는 elements 탭이다.
=> element가 변경되거나 삭제되면 관련된 html tag에 강조 표시를 띄어진다.

network 탭에서는 코드 다운로드 시간, http 왕복 시간, 코드 실행 시간 등을 알 수 있다.
=> Online를 통해서 인터넷 속도를 조절할 수 있다. 이를 통해서 성능개선의 요지를 알 수 있다.

Performance 탭은 애플리케이션이 동작할 떄 CPU 성능이나 인터넷 속도를 조절하여 성능에 관한 조작이 가능하게 한다. 또한 성능을 기록하고 판단하는 기능이 존재한다. 

Memory 탭은 스냅샷을 찍을 수 있다. 스냅샷을 찍을 당시의 애플리케이션의 메모리를 보여준다. 두 개의 스냅샷을 비교하는 것이 제일 좋은 기능이다.

Audits 탭은 성능 검사를 실행할 수 있다. 검사를 시행하면 브라우저가 애플리케이션이 어떻게 작동하는지 알아내고 결과를 보여준다.


5. 최적화 시작 시간 & 코드 사용/ 범위
JS 크기를 줄이기 위해 사용되지 않는 코드들을 지연 로딩의 도움을 개선할 수 있다. => 초기에 다운될 파일이 작아진다.
=> 해당 모듈이 필요할 떄 import를 사용해서 가져온다. => 전역적으로 import를 사용하면 전체 script를 다운하기 떄문에 크기가 커질 수 밖에 없다.


6. DOM 올바르게 업데이트 하기
하나를 업데이트 해도 전체가 렌더링되는 코드는 성능 저하를 일으킨다.

리플로우와 리페인팅에 관한 지식이 있어야 한다.
=> 이 두개가 리렌더링과 연관이 있다.


7. 마이크로-최적화 
array.unShift나 insertElementAdjacent('afterBegin')의 경우 해당 데이터를 앞에 두고 모든 데이터를 뒤로 옮기는 작업이다. 이는 모든 데이터의 이동을 요구하기 떄문에 성능 저하의 요인이 된다.

performance.now()를 통해 해당 구문이 반환되는 시간을 계산할 수 있다. 이 떄 새로고침할 떄마다 오차가 발생한다.
이 오차의 계산을 대신해주는 사이트 => jsperf.com

for, for-of의 성능의 차이는 for이 더 빠르지만 처리하는 데이터의 크기가 방대하지 않다면 미세한 차이이다.
=> 이럴때는 코드의 복잡성을 이루는 for보다 코드의 간결성을 위한 for-of 구문이 
































