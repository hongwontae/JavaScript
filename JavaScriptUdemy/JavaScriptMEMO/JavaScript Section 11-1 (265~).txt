1. 생성자 함수 소개 (prototypes-01-starting-setup)
생성자 함수 
=> 함수의 특별한 종류로 객체에 대한 블루프린트로 동작한다.
=> 프로퍼티나 메서드를 설정할 수 있다.
=> New 키워드로 생성한다.

클래스 
=> 객체에 대한 블루프린트로 동작한다.
=> 클래스는 이면에서는 function 키워드로 되어 있는 함수로 작성된다.
=> Section11/1에 증명되어 있다.


2. 생성자 함수 vs 클래스/ "New" 이해하기
클래스가 함수로 이루어졌다면 객체가 만들어져야 한다. => 함수에서 return 키워드를 통해서..
하지만 클래스는 return이 존재하지 않는다. => 객체가 반환되는 이유는 new 키워드 때문이다.

new 키워드가 이면에서 하는 일은 =>  this에 생성될 객체를 저장한다. this = {}(빈 객체), return this => 객체를 생성한다.


3. 프로토타입 소개(prototypes-01-starting-setup/ 프로토타입 완벽 공략)

JS는 프로토타입 기반 언어이다. => 다른 언어와 Class 동작 방식이 다르다.

JS는 객체는 반드시 부모 객체를 가지며 이 부모 객체를 프로토타입이라고 한다. 자식 객체는 __proto__접근자를 통해 자신의 프로토타입에 접근할 수 있다. 상속 개념이기 때문에 자식 객체는 부모 객체의 모든 프로퍼티를 사용할 수 있다.

자식 객체에 존재하지 않은 프로퍼티나 메서드를 호출했을 때 JS는 내부적으로 부모 객체에서 찾는다. 부모 객체가 없다면 그 다음 부모객체로 간다. => 이런 일련의 과정을 프로토타입 체인닝이라고 한다.

모든 객체의 최상위 객체는 Object.Prototype이라고 하고 이 객체의 부모는 null이다. 따라서 프로토타입 체이닝의 최종 종착지는 null이다.


[[prototype]]은 모든 객체에 존재하는 내부 슬롯이다. 여기에는 __proto__로만 접근할 수 있다.
프로토타입 객체의 참조값은 [[prototype]] 내부 슬롯에 저장되어 있고 __proto__접근자로 접근할 수 있다.
=> 간접적 참조이다. 직접적 참조가 안되는 이유는 프로토타입체인이 무한 로프를 도는것을 방지하기 위해서이다.


console.log(typeof Object); // function
console.log(typeof obj); // object
console.log(obj.prototype); // undefined
=> 일반 객체와 함수 객체의 차이점이 존재한다.

함수 객체와 일반 객체의 차이점은 호출 여부에 존재한다. 일반 객체는 호출 불가능, 함수 객체는 호출 가능
함수 객체에는 내부에 [[call]]메서드가 존재한다. => 호출가능
어느 객체가 내부 메서드 [[call]]이 존재하면 이를 함수라고 부르고 호출 가능한 객체를 callable이라고 한다.

함수 객체는 일반 함수와 생성자 함수로 분리가 가능하다. 구분 짓는 요소는 내부 메서드 [[Constructor]]의 존재여부이다. 이 컨스트럭터 메서드가 존재하면 함수는 생성자 함수로 동작할 수 있다. [[Constructor]]는 new와 함께 사용할 때 호출되는 내부 메서드이다.

-------------------------------------------------------------------------------------------------

생성자 함수는 인스턴스를 생생할 때마다 메서드를 중복하여 생성한다. => 모든 인스턴스가 메서드를 중복 소유한다.
=> 이는 메모리 낭비를 초래한다. => 프로토타입을 이용하여 상속을 이용하면 메모리 낭비를 방지할 수 있다.

생성자 함수로 부터 생성된 인스턴스들은 생성자 함수의 prototype을 [[prototype]]에 저장한다.

[[prototype]] => 프로토타입 참조값이다. 접근은 __proto__로 한다. 무한 루프를 막기위해서 단방향이다.
이 내부 슬롯은 프로퍼티가 아니다.

prototype 프로퍼티 => console.log(Friend.prototype === friend1.__proto__);  true

모든 프로토타입은 constructor 프로퍼티를 가지고, 이 프로퍼티는 prototype 프로퍼티로 자신을 참조하고 있는 생성자 함수를 가리킨다.


-------------------------------------------------------------------------------------------------

프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성된다.
따라서 prototype과 생성자 함수는 단독으로 존재할 수 없다.


객체 생성 방식

1. 객체 리터럴 ({ })
2. Object 생성자 함수
3. 사용자 정의 생성자 함수
4. Object.create 메서드
5. 클래스
=> 추상 연산 Ordinary Object Create에 의해 생성된다는 공통점이 있다.
 Ordinary Object Create는 필수적으로 자신이 생성할 객체의 프로토타입을 인수로 전달 받는다. 그리고 추가 옵션으로 생성할 객체에 추가할 프로퍼티 목록도 전달 받을 수 있다.

 Ordinary Object Create
1. 빈 객체를 생성한 후,

2. 인수로 전달된 프로퍼티가 있으면 이를 객체에 추가하고

3. 인수로 전달받은 프로토타입을 생성한 객체의 [[Prototype]] 내부 슬롯에 할당한 다음,

- 사용자 정의 생성자 함수일 경우 → prototype 프로퍼티에 바인딩 되어있는 객체 할당
- 객체 리터럴, Object 생성자 함수 → Object.prototype 할당

4. 객체를 반환한다.


생성자 함수와 프로토타입은 쌍으로 있어야 한다. 그러나 객체 리터럴 방식은 생성자 함수로 만든 객체가 아니다.
=> 객체 리터럴로 만든 객체  각각 Function , Object 생성자 함수가 있는 것을 볼 수 있다.

리터럴 표기법에 의해 생성된 객체도 상속을 위해 프로토타입이 필요합니다.

그렇기에 가상적인 생성자 함수를 가지게 됩니다.

그럼 생성자 함수의 짝궁인 프로토타입 또한 더불어 생성되겠죠.

(prototype, constructor 프로퍼티에 의해 연결되어 있기 때문)


프로퍼티 섀도잉
프로토타입이 소유한 메서드와 동일한 이름의 메서드를 인스턴스에 추가하면?
=>프로토타입 프로퍼티를 덮어쓰는 것이 아니라 인스턴스 프로퍼티로 추가한다. ⇒ 오버라이딩









































