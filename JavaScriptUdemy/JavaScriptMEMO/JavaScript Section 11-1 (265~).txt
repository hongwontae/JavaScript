1. 생성자 함수 소개 (prototypes-01-starting-setup)
생성자 함수 
=> 함수의 특별한 종류로 객체에 대한 블루프린트로 동작한다.
=> 프로퍼티나 메서드를 설정할 수 있다.
=> New 키워드로 생성한다.

클래스 
=> 객체에 대한 블루프린트로 동작한다.
=> 클래스는 이면에서는 function 키워드로 되어 있는 함수로 작성된다.
=> Section11/1에 증명되어 있다.


2. 생성자 함수 vs 클래스/ "New" 이해하기
클래스가 함수로 이루어졌다면 객체가 만들어져야 한다. => 함수에서 return 키워드를 통해서..
하지만 클래스는 return이 존재하지 않는다. => 객체가 반환되는 이유는 new 키워드 때문이다.

new 키워드가 이면에서 하는 일은 =>  this에 생성될 객체를 저장한다. this = {}(빈 객체), return this => 객체를 생성한다.


3. 프로토타입 소개(prototypes-01-starting-setup/ 프로토타입 완벽 공략)

JS는 프로토타입 기반 언어이다. => 다른 언어와 Class 동작 방식이 다르다.

JS는 객체는 반드시 부모 객체를 가지며 이 부모 객체를 프로토타입이라고 한다. 자식 객체는 __proto__접근자를 통해 자신의 프로토타입에 접근할 수 있다. 상속 개념이기 때문에 자식 객체는 부모 객체의 모든 프로퍼티를 사용할 수 있다.

자식 객체에 존재하지 않은 프로퍼티나 메서드를 호출했을 때 JS는 내부적으로 부모 객체에서 찾는다. 부모 객체가 없다면 그 다음 부모객체로 간다. => 이런 일련의 과정을 프로토타입 체인닝이라고 한다.

모든 객체의 최상위 객체는 Object.Prototype이라고 하고 이 객체의 부모는 null이다. 따라서 프로토타입 체이닝의 최종 종착지는 null이다.


[[prototype]]은 모든 객체에 존재하는 내부 슬롯이다. 여기에는 __proto__로만 접근할 수 있다.
프로토타입 객체의 참조값은 [[prototype]] 내부 슬롯에 저장되어 있고 __proto__접근자로 접근할 수 있다.
=> 간접적 참조이다. 직접적 참조가 안되는 이유는 프로토타입체인이 무한 로프를 도는것을 방지하기 위해서이다.


console.log(typeof Object); // function
console.log(typeof obj); // object
console.log(obj.prototype); // undefined
=> 일반 객체와 함수 객체의 차이점이 존재한다.

함수 객체와 일반 객체의 차이점은 호출 여부에 존재한다. 일반 객체는 호출 불가능, 함수 객체는 호출 가능
함수 객체에는 내부에 [[call]]메서드가 존재한다. => 호출가능
어느 객체가 내부 메서드 [[call]]이 존재하면 이를 함수라고 부르고 호출 가능한 객체를 callable이라고 한다.

함수 객체는 일반 함수와 생성자 함수로 분리가 가능하다. 구분 짓는 요소는 내부 메서드 [[Constructor]]의 존재여부이다. 이 컨스트럭터 메서드가 존재하면 함수는 생성자 함수로 동작할 수 있다. [[Constructor]]는 new와 함께 사용할 때 호출되는 내부 메서드이다.



















