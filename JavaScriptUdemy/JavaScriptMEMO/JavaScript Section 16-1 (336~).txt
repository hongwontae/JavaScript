1. JavaScript에서 숫자가 작동(동작)하는 원리
JS에서 모든 숫자는 부동 소수점 숫자이고 정수 자리와 소수점으로 이루어져 있다.
=> 모든 숫자가 부동 소수점 수로 소수점을 갖는다.

내부적으로 모든 숫자는 64비트 부동 소수점 수로 저장된다. => 내부적으로 숫자를 나타내는 데에 64비트가 사용된다.
비트 하나는 부호를 나타내는 전용이고 숫자가 양수인지 음수인지를 표시한다.
또 다른 비트는 숫자의 자릿수와  소수점의 위치를 나타내는데 사용된다.

JS에는 숫자로 표현의 최댓값과 최소값이 존재한다. 또한 소수점 수를 이용해서 구현할 수 있는 숫자의 정밀도 한계가 존재한다.

최댓값 => Numebr.MAX_SAFE_INTEGER 프로퍼티에서 확인할 수 있다. (9007199254740991) (2의 53승에서 -1한 값)
최소값 => Number.MIN_SAFE_INTEGER 프로퍼티에서 확인 가능 (-9007199254740991) (-2의 53승에서 +1한 값)
최대소수점 표시값 => Number.MAX_VALUE 프로퍼티에서 확인 가능
=> 이 최대, 최소 최대소수점 값에서 오바되는 값의 연산의 결과는 부정확하다.

JS에서는 내부적으로 이진법을 사용하지만 실제 숫자를 반환할 때는 십진법으로 변환하여 나타낸다.



2. 부동 소수점의 부정확성
0.2+04 === 0.6 => false가 반환된다. => 이진법에서 기인한 오류이다.
JS는 내부적으로 연산을 수행할 떄는 이진법을 사용한다. => 대부분의 언어는 그렇다.
JS는 연산을 이진법으로 수행하고 반환값을 다시 십진법의 수로 바꾼다. => 이 과정에서 오류가 발생한다.

toString() => 인자에 숫자를 받아서 해당된 진수로 바꾸어서 리턴한다.

JS는 이진법 계산으로는 0.2, 0.2를 제대로 나태낼 수 없다. (십진법의 1/3의 표현이라고 생각하면 된다.)
그렇기 떄문에 JS는 자체적으로 반올림을 하여 보여주는 시스템이 있다.

부정확한 부동 소수점 수를 피하는 방법
1. 부동 소수값을 정수로 치환하여 계산하는 방법
(물론 js에서는 모든 숫자가 부동 소수점 수 이다.)
2. toFixed()를 사용하는 방법
(toFixed() => 인자에 숫자를 주면 해당 숫자만큼의 소수점만 보여주며 떨궈질 마지막 숫자를 반올림 한 후에 문자열로 가져온다.)


3. BigInt
원시값에 해당하고 MAX_SAFE_INTEGER로 표현할 수 있는 숫자보다 더 큰 숫자를 표현할 떄 사용한다.
해당 숫자에 n을 붙이면 bigInt값이 된다.

bigInt는 64비트 부동 소수점 수가 아닌 문자열로 인식하고 표시한다.
양수와 음수모두 지원하며 소수점 계산은 불가능하다.

bigInt는 다른 유형의 숫자와 함께 사용되지 못한다. ( bigInt+/-* 1 => 이러한 연산이 불가능하다.)
연산을 하려면 bigInt을 정수로 바꾼든가, 정수를 bigInt로 바꿔야 한다.
































