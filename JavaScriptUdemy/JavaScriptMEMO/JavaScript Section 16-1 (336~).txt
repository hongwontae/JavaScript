1. JavaScript에서 숫자가 작동(동작)하는 원리
JS에서 모든 숫자는 부동 소수점 숫자이고 정수 자리와 소수점으로 이루어져 있다.
=> 모든 숫자가 부동 소수점 수로 소수점을 갖는다.

내부적으로 모든 숫자는 64비트 부동 소수점 수로 저장된다. => 내부적으로 숫자를 나타내는 데에 64비트가 사용된다.
비트 하나는 부호를 나타내는 전용이고 숫자가 양수인지 음수인지를 표시한다.
또 다른 비트는 숫자의 자릿수와  소수점의 위치를 나타내는데 사용된다.

JS에는 숫자로 표현의 최댓값과 최소값이 존재한다. 또한 소수점 수를 이용해서 구현할 수 있는 숫자의 정밀도 한계가 존재한다.

최댓값 => Numebr.MAX_SAFE_INTEGER 프로퍼티에서 확인할 수 있다. (9007199254740991) (2의 53승에서 -1한 값)
최소값 => Number.MIN_SAFE_INTEGER 프로퍼티에서 확인 가능 (-9007199254740991) (-2의 53승에서 +1한 값)
최대소수점 표시값 => Number.MAX_VALUE 프로퍼티에서 확인 가능
=> 이 최대, 최소 최대소수점 값에서 오바되는 값의 연산의 결과는 부정확하다.

JS에서는 내부적으로 이진법을 사용하지만 실제 숫자를 반환할 때는 십진법으로 변환하여 나타낸다.



2. 부동 소수점의 부정확성
0.2+04 === 0.6 => false가 반환된다. => 이진법에서 기인한 오류이다.
JS는 내부적으로 연산을 수행할 떄는 이진법을 사용한다. => 대부분의 언어는 그렇다.
JS는 연산을 이진법으로 수행하고 반환값을 다시 십진법의 수로 바꾼다. => 이 과정에서 오류가 발생한다.

toString() => 인자에 숫자를 받아서 해당된 진수로 바꾸어서 리턴한다.

JS는 이진법 계산으로는 0.2, 0.2를 제대로 나태낼 수 없다. (십진법의 1/3의 표현이라고 생각하면 된다.)
그렇기 떄문에 JS는 자체적으로 반올림을 하여 보여주는 시스템이 있다.

부정확한 부동 소수점 수를 피하는 방법
1. 부동 소수값을 정수로 치환하여 계산하는 방법
(물론 js에서는 모든 숫자가 부동 소수점 수 이다.)
2. toFixed()를 사용하는 방법
(toFixed() => 인자에 숫자를 주면 해당 숫자만큼의 소수점만 보여주며 떨궈질 마지막 숫자를 반올림 한 후에 문자열로 가져온다.)


3. BigInt
원시값에 해당하고 MAX_SAFE_INTEGER로 표현할 수 있는 숫자보다 더 큰 숫자를 표현할 떄 사용한다.
해당 숫자에 n을 붙이면 bigInt값이 된다.

bigInt는 64비트 부동 소수점 수가 아닌 문자열로 인식하고 표시한다.
양수와 음수모두 지원하며 소수점 계산은 불가능하다.

bigInt는 다른 유형의 숫자와 함께 사용되지 못한다. ( bigInt+/-* 1 => 이러한 연산이 불가능하다.)
연산을 하려면 bigInt을 정수로 바꾼든가, 정수를 bigInt로 바꿔야 한다.


4. 전역 Number와 Math객체
Number.POSITIVE_INFINITY => Infinity
Infinity => 무한대를 표시할 수 있는 값
inInfinite() => Infinity,NaN이라면 false 일반 숫자 유형의 값이라면 true;
isNaN() => nan이라면 true, 그렇지 않다면 false

Math라는 객체가 존재한다.
Math.floor() => 내림
Math.ceil() => 올림
Math.round() => 반올림
Math.trunc() => 소수점 버리고 가져오기
Math.max/min() => 최대 ,최소값
Math.pow() => 거듭제곱 구하기
Math.random() => 0~0.99999... => 1은 반환되는 값이 아니다.


5. 문자열 메서드 탐구하기
문자열을 만드는 방법은 세 가지이다. 작은 따옴표, 큰 따옴표, 백틱
백틱은 ${}안에 표현식을 넣어 표현할 수 있다.

문자열의 프로퍼티 & 메서드
startsWith()/endsWith() => 시작하거나 끝나는 문자가 맞으면 true 그렇지 않다면 false
indexOf()/lastIndexOf() => 문자열을 넣으면 인덱스가 반환된다. 해당 문자열이 존재하지 않으면 -1반환
charAt(); => 인덱스를 넣으면 해당 문자열을 반환한다.
substring() => 원하는 문자열을 가져오는 메서드이다. 인자가 없다면 전체, 인자가 하나라면 그 인덱스 포함하여 전체, 인자가 두 개라면 해당 인덱스부터 끝나는 인자 인덱스 까지 가져온다.
slice() = -로직을 가지 substring
etc....


6. 템플릿 리터럴 (백틱) (``)
${}에는 무조건 표현식을 넣어야 한다. => 변수를 넣어야 한다.
함수도 들어가지만 템플릿 리터럴 안에서 호출을 해줘야 한다.

템플릿 리터럴를 통해서 태그드 템플릿을 생성할 수 있다. 태그드 템플릿은 템플릿 리터럴과 함께 사용하는 함수를 일컫는다.

ex) 
function productDescription(a,b,c){
    return 'This is a product'
}

const prod = 'JavaScript Code';
const price = 3000;

const productOutput = productDescription`This is (${prod}) is {${price}}`; 
// 이 형태가 존재하면 호출된 것이다.
console.log(productOutput);

함수 표현식으로 태그 템플릿을 구성해야 한다.

태그 템플릿의 첫 번쨰 매개변수는 템플릿 리터럴에서 만들어진 Real 문자열과 ${표현식}이 모여져 있는 배열이다.
두 번쨰, 서 번쨰, 네 번쨰... 부터는 ${표현식}들이 값들이다.

함수 표현식으로 함수를 넣고 그 함수에 백틱기호를 붙여넣으면 호출된 것을 취급한다.




































