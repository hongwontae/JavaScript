1. JavaScript내의 이벤트 소개
웹페이지와 사용자의 상호작용 => JS Event
사용자의 행위로 인해 event가 트리거되어 함수가 실행된다. 이 때 함수를 이벤트 핸들러라고 말한다.


2. 이벤트를 리스닝하는 다양한 방법
각 DOM 요소들은 addEventListener에 접근할 수 있다. => 각 dom들은 event에 대한 프로퍼티나 메서드를 가지고 있다. (addEventListner, onclick, ondrag...etc)

이벤트를 추가하는 방법
1. HTML 파일에서 속성으로 추가하는 방법
=> 프로젝트를 관리하기 어려워진다. HTML코드내에 JS코드가 있기 때문에 무결성을 해친다.
=> <button onclick = function>HTML Event<button>

2. JS 파일에서 직접 트리거들은 걸어서 사용한다.
=> 이 방식은 하나의 이벤트에 하나의 함수만 사용될 수 있다.
=> 함수를 두개 사용하면 오버라이딩되어 맨 마지막에 추가된 함수만 이벤트 핸들러가 된다.
=> DOM에 트리거를 걸어버리는 것이다.

3. JS 파일에서 addEventListener를 사용하여 추가한다.
=> 동일 요소에 대해 이벤트 핸들러를 여러개 둘 수 있다.
=> removeEventListener를 통해 이벤트 리스너를 지울 수 있다.

=> addEventListener를 사용하는 것이 유용하다.
addEventListener() 
=> 인자로 두 개를 받는다. 하나는 이벤트 요소, 하나는 이벤트가 트리거 됐을 때 사용될 함수 => 이벤트 핸들러
=> 이벤트 요소는 문자열로 넣어야 한다. 다만 DOM의 붙어 있는 이벤트 요소는 on이 존재하지만 addEventListener의 이벤트 요소는 on이 붙어있지 않는다.


3. 이벤트 리스너 제거하기
dom.removeEventListener()
=> 첫 번쨰 인자로 제거할 이벤트 요소, 두 번쨰 인자로 제거될 함수를 넣는다.

초보자가 헷갈릴 removeListener의 함정
remove에 두 번쨰 인자는 함수 표현식의 변수를 넣어줘야 한다. 같은 이벤트 요소와 같은 함수일 떄만 remove가 작동하여 해당 이벤트를 삭제한다.
=> 표현식의 변수를 두 번쨰 인자에 넘겨주는 방식이 제일 좋다.


4. 이벤트 객체
Event Object는 브라우저에서 자동으로 생성되고 이벤트 핸들러(func)에 전달이 된다. 이벤트의 타겟이나 추가 메타 데이터, 이후 이벤트 동작을 제어하는 메서드를 제공한다.

event.target 
=> 어떤 요소가 이벤트의 원인이 되는지를 설명하는 프로퍼티이다. => 지금은 DOM BUTTON을 의미한다.
=> 또한 직접 요소에 대한 직접적인 엑세스도 가능하다. button을 get하는 것 뿐만 아니라 set도 가능하다는 의미이다.


5. 지원되는 이벤트 유형

mouseenter 
=> 마우스 또는 커서가 버튼을 누를 떄 트리거된다.

mouseenter.relatedTarget 
=> 마우스가 이벤트 트리거에 들어가기 전에 커서가 어떤 요소 위에 있었는지를 반환한다. (마우스가 어떤 요소를 거쳐서 들어왔냐?) 마우스를 너무 빠르게 움직이면 relatedTarget은 HTML을 가르킨다.
Browser가 마우스 커서의 위치를 지속적으로 확인하는 것이 아니라 주기적으로 확인하기 때문이다.


scroll
=> 스크롤링을 할 떄마다 트리거된다.

...etc 


6. preventDefault();
form 태그안의 button의 submit => 서버에 데이터를 전달한다.

preventDefault()
=> 이벤트 객체의 메서드이다. 모든 이벤트 객체에 존재한다.
=> 이벤트의 기본 동작을 막는다.
=> ex) form요소의 button의 기본 동작은 해당 데이터를 서버로 전송하는 것이다. 이러한 기본동작을 없애고 개발자의 로직만 갖추게 된다.



7. 캡쳐링과 버블링 단계 이해하기

DOM 이벤트 흐름에는 3가지 단계가 존재한다.
1. 캡쳐링 단계, 2. 타깃 단계, 3. 버블링 단계

버블링 => 한 요소에 이벤트가 발생하면, 이 요소에 할당된 핸들러가 동작하고, 이어서 부모 요소의 핸들러가 동작한다. 가장 최상단의 조상 요소를 만날 때까지 이 과정이 반복되면서 요소 각각에 할당된 핸들러가 동작한다.

캡쳐링 => 한 요소에 이벤트가 발생하면, 최상위 조상에서 시작해 아래로 전파된다.


8. 이벤트 전파 & stopProgagation
=> 기본적으로 모든 이벤트 리스너는 버블링 단계에서 등록된다.
=> 처음 실행되는 캡처링 단계는 완전히 무시되고 그 후에 브라우저가 내부에서 외부로 이벤트가 발생한 요소를 확인할 떄 요소 자체에 있는 리스너를 먼저 발견하기 때문에 바같부터 안쪽 순서대로 이벤트가 실행된다.

=> 캡쳐링을 의도적으로 작동시키려면 addEventListener의 세 번쨰 인자에 true를 주면 된다.
=> 캡쳐링이 시작되면 버블링 단계보다 우선순위를 갖는다.
=> 안쪽부터 바같순서대로 실행된다.

이벤트가 요소 자체에서만 트리거 되는 것이 아니라 조상에서도 트리거가 된다. 이를 전파(progagation)이라고 한다.

=> 모든 이벤트가 버블링이나 캡쳐링이 되는 것은 아니다. mouseenter, mousemove 같은 경우는 전파되지 않는다.
=> 이를 확인하려면 이벤트 객체의 bubbles 프로퍼티를 확인하면 된다.
=> event.bubbles = true/false (true면 버블링, false면 not 버블링)

stopProgagation() => 이벤트가 전파되는 것을 막는다. 해당 이벤트는 해당 DOM의 트리거에서만 작동한다. 버블링이나 캡쳐링을 막을 떄 사용하는 것이다.



9. 이벤트 위임
이벤트 리스너가 많으면 성능 측면에서 떨어진다. => forEach를 통해 다수의 이벤트를 걸어주는 코드는 효율적이지 못하다.

이벤트 위임 => 하위 요소에 각각의 이벤트를 붙이지 않고 상위 요소에서 하위 요소의 이벤트들을 제어하는 방식을 의미한다.

ex) ul안에 li가 존재한다. ul에 이벤트를 걸고 li를 클릭하면 ul의 이벤트를 li가 단독적으로 사용한다.
      (event.target를 사용했을 떄)


current.target => 이벤트가 일어난 곳을 참조한다.
event.currentTarget => 이벤트를 등록한 곳을 참조한다.
closet() => 인자에 css,id,태그를 주면 가장 가까운 요소를 반환한다. 자신을 호출하는 요소 자체도 포함한다. 

ex) 
const list = document.querySelector('ul');

list.addEventListener('click',(event)=>{
    event.target.closest('li').classList.toggle('highlight');;
})
=> 부모 DOM에 이벤트를 등록하면 각 자식들은 이벤트가 트리거가 되면 부모의 핸들러를 호출시킨다.
=> event.target은 현재 이벤트가 트리거될 떄 함수를 발동시킬 지점을 의미한다.
=> event.target.closest() => 함수를 발동시킬 지점에서 인자로 받은 가장 가까운 곳을 선택한다.
=> class.toggle()를 통해 동적으로 함수를 실행시킨다.










































