클래스와 객체 지향 프로그래밍 연습

1. 첫 번쨰 프로젝트 단계 & 계획 짜기

1.1 => static 메서드를 사용해서 객체를 생성하지 않고 메서드를 전역에서 실행한다.
1.2 => static 메서드는 두 개의 객체를 생성한다.
1.3 => 객체가 생성되었음으로 생성자가 실행된다.
1.4 => 생성자는 DOM querySelectorAll()를 통해서 id에 해당하는 li들을 가져오고 console로 보여준다.


2. Switch 프로젝트 논리로 시작하기

필드는 프로퍼티로 변환된다. => 이는 클래스 내에서 첫 번쨰로 실행됨으로 생성자에서 사용하고 메서드내에서 사용할 수 있다.

2-1 => 가져온 li 노드리스트에서 id만 빼와서 새로운 객체를 만든다.
2-2 => 2.1의 실행으로 생성자가 실행된다. 생성자의 인자에는 노드리스트의 id를 넣는다.
2.3 => 생성자에서 노드리스트의 id값을 필드로 저장하고 두 개의 메서드를 실행한다.
2.4 => this.connectSwitchButton();/ this.connectMoreInfoButton();
2.5 => connectMoreInfoButton()은 필드의 id를 가져와서 dom을 찾고 (li를 찾는다.) 그 dom에서 마지막 버튼을 찾는다. 그 마지막 버튼을 addEventListenet를 부여한다.
2.6 => 이벤트 버튼은 트리거는 click이고 두 번쨰 인자 함수는 다른 클래스에서 사용하고 싶다. 이를 위해서 다른 클래스에서 함수를 규정한다.
2.7 => addProject(), switchProject() 메서드를 ProjectList에서 생성한다.
2.8 => swtichProject()는 버튼을 눌렀을 떄 제거되는 메서드이다. 일치하는 것을 빼든가, 일치하지 않는 것을 넣는 로직을 구성해야 한다.


3. 메서드 참조 전달하기
bind(this) => 이 함수를 호출한 객체를 참조하겠다.

3.1 => 각 인스턴스에 해당하는 효과를 주기위해서 해당 인스턴스에서 clickEvent을 바인딩한다.
3.2 => setSwitchHandlerFunction를 통해서 addProject를 binding한 것을 필드로 규정한다.
3.3 => 이 메서드가 필드가 되었기 때문에 자유로이 사용할 수 있다. = 같은 클래스에서 호출하여 사용할 수 있다.


4. DOM 요소 이동시키기
이벤트 리스너를 사용할 때는 메모리 누수에 대해서 생각해봐야 한다. eventListener의 로직이 조건에 따라 체인지된 경우 메모리 누수가 발생한다.

전체적인 로직
DOM요소를 이동시키는 DOMHelper 클래스를 사용한다.
인스턴스 a와 b를 이동시키는 로직이기때문에 이벤트 누수가 발생해서 이벤트를 cloneNode를 통해 새롭게 만든다.
동적으로 append를 사용한다.


5. 툴팁 추가하기





























































