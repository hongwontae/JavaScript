1. 클래스는 생성자 함수의 확장 개념이다.

2. 생성자 함수나 클래스는 함수이다. 함수는 객체이다.

3. new Logic
3-1. this에 빈 객체를 할당한다.
3-2. 함수본문을 실행하여 this의 빈 객체에 프로퍼티를 할당한다.
3-3. this 객체를 반환한다.

4. 프로토타입
js는 프로토타입 기반언어이다. 객체는 무조건 [[prototype]]을 가지고 있다. 부모 객체라고 생각해도 된다.
[[prototype]]에 접근할 수 있는 접근자는 __proto__ 이다. 순환참조를 막기 위해서이다.

모든 객체의 최상위 조상은 Object.prototype이다. => 이 객체의 부모는 null이다.

객체에 접근했는데 해당 프로퍼티나 메서드가 없다면 [[prototype]]에서 찾는다. => 프로토타입 체이닝

prototype => 객체에 할당할 프로토타입
[[Prototype]] => 프로토타입 체이닝이 일어나는 부모 객체
__proto__ => [[protoType]]에 접근할 수 있는 접근자이다.

일반 객체 => 호출 불가능, 함수 객체 => 호출 가능
함수 객체 => 일반 함수 => 컨스트럭터 메서드x, 생성자 함수 => 컨스트럭터 메서드 존재

constructor => 생성자 함수로 만든 객체는 constructor가 존재한다.

객체 리터럴로 만든 객체의 [[prototype]]은 Object.prototype이다. 


class 내부의 메서드는 객체에 할당될 떄 [[prototype]]으로 할당된다. => js엔진이 메모리를 아끼기 위해서 그렇게 한다.

객체 내부에 있게 하려면 => 1. constructor에서 메서드를 추가한다. 2. 축약구문을 사용하지 않고 함수 표현식을 사용한다.


5. 프로토타입 getting/setting
Object.getPrototypeOf(객체) => 인자의 객체의 프로퍼티를 확인하는 메서드
Object.setPrototypeOf(객체, 프로토타입 프로퍼티) => 인자의 객체에 프로토타입을 고급지게 설정하는 방법























