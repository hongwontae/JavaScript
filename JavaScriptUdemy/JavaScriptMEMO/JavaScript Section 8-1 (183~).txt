1. Iterable과 유사 배열 객체란?
Iterable과 유사 배열 객체는 배열이 아니다.
Iterable은 반복가능한 객체를 의미한다. => Symbol의 개념을 알아야한다. 나중에 알아보자
유사 배열 객체는 nodelList, HTMLCollection, String etc....

두 객체는 for-of를 사용할 수 있고 길이(length)를 가지고 있다. 이를 제외하면 일반배열에서 사용할 수 있는 메서드들을 사용할 수 없다.



2. 배열 생성하기 (arrays-01-starting-code)
일반적인 방법 => const number = [1,2,3,4,5] / 예외적인 사항을 제외하고 대부분 이 방식을 사용한다.
길이는 1부터/ 인덱스는 0부터

const moreNumber = new Array(1,2,3); => (3) [1,2,3]
생성자 함수를 사용하여 배열을 생성하는 방법이다. 마찬가지로 배열의 타입은 일정하지 않아도 된다.
다만 배열 생성자 함수에 단일 숫자만을 넣게 되면 그 숫자만큼 빈 배열이 생성된다.
new는 생략이 가능하다.

const yetMoreNumber = Array.of(1,2) => (2) [1,2]
일반적인 배열 생성의 로직과 같다.

const arrayFrom = Array.from(..);
=> Array.from 안에는 Iterable이나 유사 배열 객체가 들어가서 일반 배열로 반환되는 메서드이다. 일반 배열을 넣어도 된다.

ex) const arraylike = Array.from("Hi!") => (3) ['H','i','!']
   => 유사배열객체 = String이 일반 배열로 반환된다.


3. 배열의 데이터 저장하는 로직
배열의 값으로 넣을 수 있는 것은 거의 제약이 없다. 매우 유연하다.

ex) const arr = [1,2,3,function ko(){}, {ko:1},[1,[1,2],3]]
console.log(arr)


4. push, pop, unshift, shift
push => 배열의 마지막에 추가한다.
unshift => 배열의 첫 번쨰에 추가한다.
pop => 배열의 마지막를 삭제한다.
shift => 배열의 첫 번쨰를 삭제한다.
shift와 unshift는 배열의 모든 요소에 영향을 미치며 모든 요소를 이동시킨다.
shift와 unshift는 push,pop보다 성능이 떨어진다.

인덱스를 사용해서 배열에 접근하는 것은 값을 교체하는 것이다.
존재하지 않은 인덱스(배열의 위치)에 값을 할당할 수 있다. => 두 개의 배열 요소가 존재하고 [4]에 접근하여 배열의 값을 주었으 떄 3,4의 값은 undefined로 채워진다.

const popop = hobbies.pop(); => 실행된다.



















































