1. Iterable과 유사 배열 객체란?
Iterable과 유사 배열 객체는 배열이 아니다.
Iterable은 반복가능한 객체를 의미한다. => Symbol의 개념을 알아야한다. 나중에 알아보자
유사 배열 객체는 nodelList, HTMLCollection, String etc....

두 객체는 for-of를 사용할 수 있고 길이(length)를 가지고 있다. 이를 제외하면 일반배열에서 사용할 수 있는 메서드들을 사용할 수 없다.



2. 배열 생성하기 (arrays-01-starting-code)
일반적인 방법 => const number = [1,2,3,4,5] / 예외적인 사항을 제외하고 대부분 이 방식을 사용한다.
길이는 1부터/ 인덱스는 0부터

const moreNumber = new Array(1,2,3); => (3) [1,2,3]
생성자 함수를 사용하여 배열을 생성하는 방법이다. 마찬가지로 배열의 타입은 일정하지 않아도 된다.
다만 배열 생성자 함수에 단일 숫자만을 넣게 되면 그 숫자만큼 빈 배열이 생성된다.
new는 생략이 가능하다.

const yetMoreNumber = Array.of(1,2) => (2) [1,2]
일반적인 배열 생성의 로직과 같다.

const arrayFrom = Array.from(..);
=> Array.from 안에는 Iterable이나 유사 배열 객체가 들어가서 일반 배열로 반환되는 메서드이다. 일반 배열을 넣어도 된다.

ex) const arraylike = Array.from("Hi!") => (3) ['H','i','!']
   => 유사배열객체 = String이 일반 배열로 반환된다.


3. 배열의 데이터 저장하는 로직
배열의 값으로 넣을 수 있는 것은 거의 제약이 없다. 매우 유연하다.

ex) const arr = [1,2,3,function ko(){}, {ko:1},[1,[1,2],3]]
console.log(arr)


4. push, pop, unshift, shift
push => 배열의 마지막에 추가한다.
unshift => 배열의 첫 번쨰에 추가한다.
pop => 배열의 마지막를 삭제한다.
shift => 배열의 첫 번쨰를 삭제한다.
shift와 unshift는 배열의 모든 요소에 영향을 미치며 모든 요소를 이동시킨다.
shift와 unshift는 push,pop보다 성능이 떨어진다.

인덱스를 사용해서 배열에 접근하는 것은 값을 교체하는 것이다.
존재하지 않은 인덱스(배열의 위치)에 값을 할당할 수 있다. => 두 개의 배열 요소가 존재하고 [4]에 접근하여 배열의 값을 주었으 떄 3,4의 값은 undefined로 채워진다.

const popop = hobbies.pop(); => 실행된다.


5. splice()
매개변수를 n개 까지 넣을 수 있다.
첫 번쨰 매개변수에는 시작 숫자를 지정한다. (길이)
두 번쨰 매개변수에는 삭제하려는 항목의 수를 지정한다. (인덱스)
세 번쨰 매개변수에는 삭제된 값의 위치에 삽입될 item이라는 인수를 원하는 만큼 추가할 수 있다.

splice 메서드에 하나의 인자만 넣는다면 지정한 숫자의 길이을 제외하고 다 지우라는 뜻이다.
(0이면 다 지운다.)
=> [1,2,3,4,5,6,7,8,9,10] => splice(0)/모조리 삭제, splice(2)/ 1,2출력, splice(5)/1,2,3,4,5
splice()는 삭제한 요소를 반환한다.

첫 번째 매개변수에 음수를 넣으면 오른쪽부터 시작한다.

=> 배열을 삭제하거나 교체하는 메서드


6. slice()
slice는 새로운 배열을 반환한다. => 배열을 복사하는 유용한 방법이다.

-- 배열은 참조값을 가진다. => 주소값을 가진다. 하나의 배열을 복사해서 다른 변수에 주게되면 주소값을 주게 되는 것이다. 독자적인 값을 갖는 것이 아니다. 이렇게 되면 두 개의 배열은 같은 주소값임으로 하나의 배열의 변경에 두 개의 배열에 영향을 미치는 것이다. => 개발자가 원하는 방향이 아닐 수 도 있다. 이 떄 slice()는 복사하여 완전히 새로운 참조값을 가지기 때문에 유용하다.

slice()의 매개변수 로직은 첫 번쨰 매개변수index, 두 번쨰 매개변수 길이
매개변수의 개수가 하나라면 해당 인덱스부터 끝까지 배열을 복사한다.
매개변수의 개수가 두 개라면 해당 인덱스부터 두 번쨰 숫자 길이까지 배열을 복사한다.
매개변수가 개수가 하나이고 음수이면 길이로직이다. 왼쪽부터 시작하고 끝까지 복사한다.


7. concat()
배열 끝에 요소를 추가해서 연결할 수 있도록 한다.
1개나 그 이상의 배열을 취해 해당 배열과 연결할 배열을 연결한다.
반환값은 새로운 요소이다. 

ex) const a1 = [1,2,3,4,5]
   const a2 = a1.concat([6,7,8]) => a2 = [1,2,3,4,5,6,7,8] (새로운 배열값이다.)


8. indexOf()/ findIndex()
indexOf() => 배열 안의 값에대한 인덱스를 반환한다. 두 번째 인자도 넣을 수 있다. 두 번쨰 인자의 역할은 시작 인덱스를 지정할 수 있는 선택적 인수를 사용해서 그 이후의 요소만 검색하게 한다. (동일한 값(1.5)가 2번 인덱스에 10번 인덱스에 있다고 가정했을 떄 indexOf(1.5)의 반환값은 2이다. 그러나 두 번쨰 인자에 2를 넣으면 indexOf(1.5,2)의 반환값은 10이다.) => 첫 번쨰 요소를 찾으면 종료한다.

lastIndexOf() => 위의 로직과 같지만 오른쪽부터 찾는다.

indexOf의 값이 없다면 -1이 반환된다.
참조값은 indexOf의 매개변수가 될 수 없다. => -1이 반환된다.


9. find()/ findIndex()
find() => 인자로 함수를 취한다. 함수의 매개변수로 첫 번째 인자는 배열의 단일객체이다. 두 번쨰 인자는 해당 단일 요소의 인덱스이다. 세 번쨰 인수는 전체 배열이다. {} 함수 로직은 사용자가 원하는 객체의 값을 찾는 로직을 Boolean으로 구성하면 된다. 반환값은 객체자체이다.

ex) const mal = personData.find(person,idx,persons){
  return person.name === 'Manuel'
}

console.log(mal) => {name = 'Manuel'}

findIndex()도 같은 로직을 따르지만 반환값은 인덱스이다.

=> 이 두개의 메서드는 값을 복사하는 로직이 아니기 때문에 같은 주소값을 가지고 있다. 잘 생각하고 사용해야 한다.












































