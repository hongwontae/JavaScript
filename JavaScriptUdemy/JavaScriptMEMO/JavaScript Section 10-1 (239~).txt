1. OOP 코드로 시작하기
oop-01-starting-setup => 참고

for(const prod of this.products)
....
productList.render();
=> productList의 객체 products를 참조한다.

const productList = {
    products :[
    {
        title : 'A soocer player',
        imageURL : 'https://cdn.pixabay.com/photo/2023/05/25/07/31/woman-8016553_1280.jpg',
        price : 2000,
        des : 'A cool girl'
    },
    {
        title : 'S soccer player',
        imageURL : 'https://cdn.pixabay.com/photo/2023/08/28/23/17/superb-fairywren-8220199_1280.jpg',
        price : 2000,
        des : 'He is good player'
    }
]

=> 그니까 productList의 products : => [] 여기부터 값을 가진다. 그러므로 for-of 반복문을 사용할 수 있다.


2. 클래스 정의와 사용하기
클라스 기반으로 객체를 만든다 => 자바의 객체지향과 유사하다.
new는 클래스를 기반으로 한 함수의 실행과 함꼐 인식된다. => 새로운 객체를 생성한다.

ex) class Product {
  title;
  price;
  koala3121;
}

console.log(new Product())

{title : undefined, price : undefined, koala3121 : undefined} => new Product() => 객체를 생성한다.


3. 생성자 메서드로 작업하기
java 생성자 메서드와 비슷하다.

ex)   constructor (title, image, desc, price) {
    this.title = title;
    this.imageURL = image;
    this.description = desc;
    this.price = price;
  }

=> constructor라는 키워드 () {}
=> () 인자에는 new class이름() 할떄 매개변수로 받을 객체의 값이다.
=> {}의 로직은 this는 class의 필드를 의미한다. 


4. 필드 vs 프로퍼티
class Product{

  //title = 'DEFAULT';
  //imageURL;
  //description;
  //price;

  constructor (title, image, desc, price) {
    this.title = title;
    this.imageURL = image;
    this.description = desc;
    this.price = price;
  }

  printInfo() {
  console.log('asd')
}

}

=> title = 'DEFAULT'를 부를 때 클라스의 필드라고 부른다.
=> this.title = title => 클라스의 속성이라고 부른다.
=> 클라스 기반으로 객체를 생성하면 필드가 속성이 된다.
=> printInfo(){} => 클래스의 메서드라고 부른다.
=> 생성자를 만들면 필드가 의미가 없어진다. 자바와는 다르게 생성자가 있으면 필드를 거치지 않고 자동으로 객체를 생성한다.


5. 다수의 클래스 사용하고 연결하기
클래스는 실행할 코드 전에 정의되어야 한다.


6. 생성자 함수 this
객체를 생성하는 방법은 두 가지이다. 객체 리터럴을 사용하는 방법과 생성자 함수를 사용하는 방법이다.

생성자함수를 사용하는 방식 => const a = new Date();
사용자가 직접 생성자 함수를 만들어서 사용할 수 도 있다.

































