1. 데이터 타입(데이터 타입을 자료형이라고 부르기도 한다.)
JS의 타입은 원시 타입과 객체타입으로 나뉜다. 원시타입은 Number, String, Boolean ,null ,undefined ,symbol (ES6에서 추가됨)/ 객체타입은 Object, Array이다.

undefined는 변수에 특정한	 값을 할당하지 않았을 때나 함수의 매개변수가 들어오지 않았을 때 할당이 된다.


2. 문자열 작성 방법(feat.템플릿 리터럴)
문자열은 "", '', ``로 감싸주어야 JS가 인식한다. 
"",''는 한 줄에 문자열이 다 들어가야 한다./ 템플릿 리터럴은 구애를 받지 않는다.

템플릿 리터럴은 백틱으로 문자열을 감싸고 동적으로 js표현할 때 사용한다. 
백틱안에 ${} => 아 안의 코드는 문자열로 인식하지 않고 JS코드로 인식되어 로직이 실행된 후 문자열이 된다. 


3. 함수 선언과 호출
함수의 선언 => function add () {}/ 함수의 호출 add();

함수의 호출+매개변수 add(1,3)

함수안의 객체 + 호출 + 매개변수
function add (num1,num2) { const oo = {price:num1, age:num2}} 일 떄 add(1,3)를 호출하면 1,3의 매개변수가 num1,num2가 된다. price : 1/ age :3이 된다는 이야기이다.


4. 인풋태그의 값을 JS로 불러올 때 생기는 일
인풋태그의 값을 js로 불러오면 무조건 String형태로 받는다. 이를 해결하기 위해 받은 value를 parseInt()/parseFloat으로 받는다.


6. TypeOf
데이터 타입을 확인하는 키워드이다. 하지만 항상 반환값은 문자열로 감싸서 보내준다.
 Typeof "asd" => "String"/ TypeOf 1 === number false/ TypeOf 1 === 'Number' true


7. defer/asnyc
html에 js코드를 넣었을 때 body태그 위에 넣는다. 그 이유는 html구문 분석이 끝나고 js파일을 실행해야 올바른 위치에 js파일과 html파일이 연결되기 때문이다. 하지만 이 경우 파일의 용량이 크면 성능의 저하가 발생한다. (js 다운로드도 html구문분석이 끝나야 시작하기 때문)
스크립트 태그에 defer라는 키워드를 붙여주면 html과 스크립트 다운이 동시에 시작되고 html구문 분석이 끝나면 바로 실행시킨다. => 대부분이 이 방법을 사용한다.

async는 html과 js파일이 연결성이 떨어질 떄 사용한다. 스크립트 태그에 async라는 키워드를 넣으면 html구문 분석과 js다운이 실행되고 html 구문 분석은 개의치 않은채 js파일을 실행시킨다. 빠르긴 하나 안정성이 떨어진다.












