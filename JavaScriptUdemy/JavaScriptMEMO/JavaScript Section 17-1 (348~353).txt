1. 동기 코드 실행 이해하기 ("Sync Code")
JavaScript는 단일 쓰레드이다. => 알고 있었다.
=> 단일 쓰레드라는 말은 한 번에 한 가지 일만 할 수 있다는 것이다.

a : console.log()
b : func()
c : moreCode()
d : button.disabled = true;

JS는 위에서부터 아래로 코드를 읽어드린다.
(함수 선언문이나 var 같은 경우를 제외하고..)
b의 함수가 호출되어 완료되기 전까지 c는 실행되지 않고 기다린다. b가 사실상 c의 실행을 막고 있는 것이다.
=> 순차적으로 실행된다. 이는 JS 코드에서 DOM을 먼저 만들고 addEventListener를 만드는 이유이기도 하다.


2. 비동기 코드 실행 이해하기
console.log() => setTimeout() => moreCode()
=> setTimeout()의 시간이 길다면 결국 코드의 성능이 떨어지는 효과를 일으킨다.
=> setTimeout()이 다른 코드의 실행을 막고 있다.

위의 현상을 해결하기 위해 JS와 브라우저는 비동기 코드 실행을 한다.
시간이 오래 걸리는 작업을 하는 코드를 브라우저에서 오프 로드(off-Load)시킬 수 있다.

위의 코드를 예시로 들어 setTimeout()를 호출하여 브라우저에 타이머를 설정한다. 즉, 브라우저가 쓰레드 역할을 하게되고 setTimeout()이라는 함수를 브라우저에서 관리하게 되는 것이다. => 이러한 구조 떄문에 JS의 코드는 막히지 않는다.

위 같은 현상 때문에 JS와 Browser가 의사소통할 수단이 필요하다. 그 방법으로 콜백함수를 사용한다.
setTimeout()이 브라우저에서 관리되고 콜백함수가 브라우저에서 연산이 끝나면 호출할 함수가 되고 브라우는 다시 스크립트로 돌아가서 함수를 실행한다.

브라우저가 JS 코드의 실행을 간결하고 효율성있게 만들어준다.


3. 코드 차단하기 & "이벤트 반복문"
루프가 끝나야 이벤트가 발생한다. => for 루프는 Browser에 전달되는 코드가 아니다. 연산이 끝나기 전까지는 JS코드의 진행을 막는다.

버튼 이벤트를 브라우저에게 넘긴다. => 다음 코드로 진행된다. => for은 js 코드 진행을 막는다. => for 연산중에 이벤트가 트리거 되어 함수를 실행시켜야 해도 js 로직은 우선적으로 자신의 코드 실행을 우선시한다. => 항상 이벤트 핸들러가 나중에 실행된다.

코드가 실행되면 JS엔진의 일부인 스택에서 작업이 이루어진다. 또한 브라우저에서는 비동기 코드 항목들이 오프로드 된다. 브라우저는 JS 코드 내부에서 특정 브라우저 API와 소통할 수 있는 다리를 준다.

ex)
const greet(){console.log('Hi')};
const ShowArt = ()=>{alert('Danger')}
setTimeout(showArt, 2000);
greet()

setTimeout()은 JS내에 생성되어 있는 브라우저 API(브라우저)이기 때문에 브라우저에 현재 진행중인 타이머를 브라우저 내부에 설정한다. => 브라우저가 타이머를 관리하게 되었다. (JS 코드 실행 절차에서 빠지게 되었다.) 

만약 greet() 실행중에 브라우저 함수가 호출되야 한다면?
메시지 대기열(message Queue)을 사용한다. 이 기능은 브라우저에서 지원될 뿐만 아니라 JS와도 연결되어 있다.
메시지 대기열에서는 브라우저가 시간이 생길 떄에 실행해야 하는 모든 코드를 저장해 놓는다. (setTimeout()은 타이머가 그 시기를 알려준다.)

위의 예제에서 메시지 대기열은 showAlert()이 시간이 나면 해야 할 task로 지정되어 있다. JS 코드 진행에 따라 모든 코드가 진행되고 나면 메시지 대기열의 코드가 실행되어야 하는데 이를 위해서 이벤트 루프를 이용한다.

이벤트 루프는 브라우저의 빌트인 기능이다. JS의 호스트 환경 중 일부이다. 즉, 이벤트 루프는 브라우저의 일부이며 이벤트 루프의 역할은 엔진의 호출 스택을 대기 중인 메시지와 동기화하는 데에 있다. 이벤트 루프는 항시 실행중인 상태이다.
호출 스택이 비워져있다면 메시지 대기열의 대기 중인 작업이 있는지 확인하고 있다면 이벤트 루프가 실행되어서 대기 중인 메시지나 작업 대상인 함수를 호출 스택으로 푸시한다.
(이벤트 루프는 호출 스택이 비워져 있다면 메시지 대기열에 메시지나 콜백함수의 여부를 확인하여 호출 스택에 푸시하는 작업을 뜻한다.)


4. 동기화 + 비동기화 코드 - 실행순서
ex) 
function trackUserHandler() {
  navigator.geolocation.getCurrentPosition(posData => {
    console.log(posData)
  }, error => {
    console.log(error)
  })
  console.log('Getting position');
}

=> 위의 코드로 JavaScript의 비동기 코드를 설명해보자
getCurrentPosition이라는 메서드는 상대방의 위치를 가져오는 메서드이고 인자로 3개를 받는다. (콜백함수, 콜백함수, 객체/ 첫 번쨰 콜백함수는 위치를 가져오는데 성공했을 떄 사용하는 함수, 두 번쨰 콜백함수는 위치를 가져오는데 실패했을 떄 사용하는 함수, 세 번쨰는 이 메서드에 관한 객체이다.) trackUserHandler가 실행되면 내부의 콜백함수들은 메시지 대기열로 간다. trackUserHandler의 마지막 console.log()는 호출 스택으로 간다. 메시지 대기열에서 호출스택으로 푸시하기 위해서 호출스택이 비워져 있는지 확인한다. => 항상 기존의 호출스택이 먼저 실행된다.
마지막 console.log()가 항상 먼저 실행되고 위의 콜백함수가 실행된다.


5. 다수의 콜백 & setTimeout()
비동기 연산안에 비동기 연산을 포함할 수 있다.
setTimeout(()=>{console.log('Timer Done')},0)라 하더라도 호출스택이 비워진 이후에 실행된다.






















































