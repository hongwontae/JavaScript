1. 프로젝트 제한 & 도구가 필요한 이유
스크립트 파일을 여러 개로 분리하여 사용하면(모듈) HTTP 통신으로 스크립트 파일이 통신한다. 이때 비효율성이 야기될 수 있음으로 JS 도구를 사용한다.

JS 도구를 사용해야 하는 이유
1. 모듈을 그냥 적용하면 CORB의 제약이 걸리고 CORB의 제약을 풀기위해 서버에서 스크립트를 실행하면 대형 프로젝트를 경우 많은 HTTP 통신 요청으로 성능의 제약이 걸릴 수 있다.

2. JS 코드는 최적화가 필요하다. => 변수의 이름이 길다면 브라우저가 다운로드할 용량이 커지는 것이다. 이때 도구를 사용하면 개발자가 보는 코드 명은 그대로인데 브라우저나 컴퓨터가 읽는 스크립트의 변수명은 간단명료하게 바뀌어 읽을 수 있다.

3. 브라우저 지원 문제를 해결할 수 있다. => 구형 브라우저에서는 지원되지 않은 기능들을 도구가 서포트 한다.

4. 개발하거나 개발한 코드를 수정한 것을 보기 위해서 브라우저 새로 고침이 필요하다. => 이를 자동으로 도구가 해결해 준다.

5. 코드 품질을 향상시켜준다. 


위의 사항을 개선하기 위한 도구들은 이미 만들어져 있다.
개발 서버 - webpack-dev-server or serve - 자동 새로고침
버들링 도구 - Webpack - 모듈로 분할된 코드들을 결합한다.
코드 최적화 도구 - webpack Optimizer Plugins - 함수의 이름을 축약하거나 공백을 제거하는 최적화 기능
Code Compilation Tool - Babel - 최신 코드를 작성하더라도 구형 브라우저에서 돌아가게 해주는 기능
Code Quality Checker - ESLint - 코드의 일관성이나 지켜야 할 규칙을 검사하는 기능


2. 워크 플로우 개요
개발자가 코드를 작성할 떄 사용할 수 있는 워크 플로우가 두 가지 존재한다.

1. 코드에 변경 사항을 저장할 떄 실행되는 개발 워크 플로우
코드를 확인하고 코드 품질 문제가 있는지를 확인하기 위해 Lint 설정을 해야한다.
코드를 번들 처리하여 서로 다른 여러 개의 파일들을 몇 개의 큰 파일로 묶어서 불필요한 http 요청을 막는다.
개발 서버가 코드 변경될 떄마다 자동 새로고침을 하게 해준다.

2. 특정 명령에 의해 실행되는 생산 워크 플로우
Lint가 필요하다.
Webpack의 도움을 받아 코드를 번들 처리한다.
구형 브라우저에서 최신 코드들이 돌아갈 수 있게 JS 코드를 변환한다.
최적화를 진핸한다.

=> 위의 두개를 사용하려면 npm, NodeJS가 필요하다.

npm (Node Package Manager)
=> 여러 가지 도구들을 설치하는 데 사용되며 도구들을 조정하고 다른 워크플로우를 시작하는 등에 쓰인다.


3. npm 프로젝트 설정하기 and eslint 설정
npm를 설치하기 원하는 곳을 지정한다. => 전역으로 지정하면 관리하기 오히려 어렵다.
Terminal => npm init => 각 질문에 답 => terminal 위치에 package.json이 설치된다.
=> package.json을 통해서 설치와 각종 설정으로 스크립트 파일을 관리할 수 있다.

npm install --save-dev eslint => eslint을 사용하기 직전의 설정
npm init @eslint/config => eslint 파일을 설치하고 설정하는 명령어


4. ESLint 사용법
ESLint는 오류를 잡아주는 tool이 아니다. 일관성을 해치는 코드 구문을 오류처럼 보이게 하여 잡아주는 도구이다.
일관성을 해치는 코드 설명은 eslintrc.json에 존재하고 직접 구문을 조작하여 off로 만들 수 도 있다.
=> 항상 설정이 고비다.


5. 웹팩으로 번들링하기
별개의 파일들을 하나로 합치는 기술 => 번들링
번들링을 위해서 webpack이라는 도구를 사용한다.

webpack는 번들링 외에 전체 워크플로우를 조정하는 것도 도와준다. webpakc.org.js => 공식 사이트

설정
1. 원하는 위치에 npm install --save-dev webapck webpack-cil 명령어를 terminal에 입력한다.
2. package.json에 webpack과 webpack-cil의 버전이 명시되어진다.
3. package.json이 있는 파일과 동일한 레벨에서 webpack.config.json를 만든다.
=> 이 파일은 nodeJS 구문으로 돌아간다. module.export = {} => nodeJS가 {}를 파일 밖에 노출시키는 구문이고 설치한 webpack이 해당 객체를 가져온다. 즉, 웹팩을 구성하는 구성 객체
4. webpack의 번들링 작업을 위해서 시작포인트를 알려줘야 한다. => webpack이 시작포인트 스크립트를 분석하여 하나로 만든다.

module.exports 객체의 설정으로 번들링 파일이 생성된다. => 번들링 파일를 만들기 위해서는 코드의 시작지점(entry 객체), 번들링 파일 설정(output 객체)가 필요하다.
















































