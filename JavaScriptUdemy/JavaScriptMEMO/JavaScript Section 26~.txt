1. Basic Function (basics-06-basic-function)
Define Function => 함수를 메모리 상에 저장해둔다. 아직 실행되지는 않는다.
Call funcktion => 함수를 호출한다. 이 행동이 함수를 실행시키는 것이다.

함수는 필요에 따라 매개변수를 받는다./ 매개변수는 함수을 동적으로 작동시키는 것이라 보면 된다.
함수에 매개변수를 주면 변수의 이름이 아니라 변수의 값이 전달되는 것이다.

함수의 선언은 function 함수이름 () {}
함수의 호출은 함수이름();

-- 자바스크립트의 문자열은 한 줄에서만 인식된다.


2. Return(basics-07-function-with-return)
함수가 호출되었을 때의 결과값을 건너주는 키워드

ex) function add (num1, num2) {
 const result = num1+num2
 return result
}

currentResult = add(1,3);

return이 없다면 값이 전달되지 않는다.

Return 밑에 있는 코드는 실행되지 않는다. Return문부터는 코드가 시작되지 않는다.


3. Code 순서 (basics-07-function-with-return app1.js)
변수나 상수를 사용하기 전에 먼저 선언을 해야한다. Js는 위에서부터 아래로 내려가면서 코드를 확인하는데 선언된 변수가 없는데 변수에 값을 할당하려고 하면 오류가 발생한다.

JS의 작동방식은 
위에서부터 아래로 코드를 읽는다. => 읽은 함수를 등록한다. => 페이지 내에서 함수가 호출되면 그떄 실행된다.
그렇기 때문에 함수의 위치는 자유롭다.


4. 전역, 로컬 범위 (basics-07-function-with-return app1.js)
변수는 선언되는 동시에 자신만의 Scop를 갖는다./ 지역변수는 함수 내에서 전역변수보다 더 높은 우선순위를 갖는다.

함수는 외부에 정의된 변수 및 상수에 엑세스할 수 있어서 전역적으로 정의된 변수나 상수를 읽을 수 있다.

로컬(Block) Scope => 함수 내부에 상수나 변수를 정의를 했을 떄의 범위 
Local Scope는 정의된 위치에서 벗어날 수 없다. {} 중괄호 내에서 벗어날 수 없다는 이야기이다.

그러나 함수는 주변의 모든 범위에서 값을 가져와서 사용할 수 있다. 모든 변수에 엑세스가 가능하다.


5. Function 간접적으로 실행하기
함수안에 함수가 존재할 수 있다. 즉, a라는 함수에 b함수가 존재할 떄 a함수를 호출하면 b함수도 호출되는 개념이다.


6. add() VS add
add(); => 함수를 바로 호출해라
add => 조건이 충족되면 실행해라

ex) addBtn.addEventListener('click', add); => click이 되었을 떄만 add함수를 실행해라


7. 자료형 변환하기
HTML 코드 상 Input 태그가 숫자 유형(number)로 되어 있다 해도 JS로 가져올 때는 항상 문자열이 된다.
비단 숫자 유형 뿐만 아니라 다른 유형이라도 모조리 문자열로 가져온다.

ParseInt() => 문자열을 소수점 이하 숫자가 없는 수로 구문 분석하는 함수이며 ParseFloat은 소수점 아래 자리가 있는 수로 분석한다. 즉, 문자열을 숫자로 바꿔준다.

문자열 앞에 있는 +는 문자열을 숫자로 전환한다.
ex) currentResult = currentResult+ +parseInt(userInput.value)

숫자를 문자열로 변환 => toString()

연산자 High
3+'3' => '33' (문자열)/ +는 텍스트를 결합할 수 있는 특성이 있어서 이 방식으로 작동한다.
3-'3' => 0 (숫자)
3*'3' => 9 (숫자)


-- 템플릿 리터럴의 +기호는 접합시켜주는 것이 아니라 문자 그대로 +가 출력된다. (+ 기호가 의미없기 때문이다.)
-- 생각해보면 '', ""도 마찬가지이다. (''+'' => 이거니까.. 조금 헷갈렸다.)


8. 리팩토링
중복된 코드를 함수나 변수로 빼는 작업/ 코드를 명확하게 하는 작업


9. 주석
// => 한 줄 주석
/* 범위  */ => 범위 내 주석


10. 연산자
+= => ex) currentValue = CurrentValue+5 = currentValue+=5
-= => ex) currentValue = currentValue-5 = currentValue-=5
*과 나눗셈도 마찬가지이다.

++/-- => 증가연산자/ 증감연산자
증가/감소 연산자가 앞에 붙으면 return전에 값은 기존의 값이다.
증가/감소 연산자가 뒤에 붙으면 return값과 return전의 값은 같다.


11. 데이터 타입2
Boolean => true/false
Object => {name : 'hwt', age : 12} => 객체타입
Array => [1,3,5], [1,'3',true] => 배열의 데이터 타입은 객체이다.


12. 















































