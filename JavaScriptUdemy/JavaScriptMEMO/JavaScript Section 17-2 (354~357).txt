1. 프로미스 시작하기
수많은 콜백함수가 겹쳐져 있는 경우 => 읽기도 어렵고 해석하기도 어렵다.
=> 이를 콜백지옥 (callback hell)이라고 부른다.

위의 사안을 해결하기위한 것이 프로미스이다.

오래된 구문들은 프로미스를 지원하지 않는다. (setTimeout()같은 경우..)

프로미스는 JS에 내장된 클래스라서 생성자 함수를 통해 만들 수 있다. (const promise = new Promise();)
이 프로미스는 함수를 인자로 받는다. 이 함수는 프로미스 API라서 프로미스가 생성될 때 바로 실행된다.
=> 생성자 내부에서 바로 실행된다. new Promise()의 함수 본문이 바로 실행되는 것이다.

생성자의 인자의 함수의 매개변수는 두 개가 들어간다. 보통 이름은 resolve, reject로 짓는다.

프로미스에 then을 추가하면 이 프로미스가 무엇을 해결하든 실행한다.

=> 프로미스는 비동기 함수 코드를 간결하게 만들기 위한 것이다.


2. 다수의 프로미스 체이닝(Chaining)
Promise의 then인자에 또 다른 콜백함수를 반환하면 원래 프로미스는 fulfilled에서 pending으로 바뀌게 되고 반환된 함수를 해당 프로미스가 해결할 떄까지 기다려야 한다.

then()은 프로미스의 메서드이다. 이 함수는 프로미스가 이행되거나 거부될 떄 실행될 콜백함수를 취한다.

프로미스가 이행되면 .then() 함수는 프로미스의 결과를 콜백 함수의 첫 번째 인수로 전달한다. 프로미스가 거부되면 .then() 함수는 프로미스의 오류를 콜백 함수의 첫 번째 인수로 전달한다.

.then() 함수는 Promise를 반환하므로 .then() 함수를 체인으로 연결하여 여러 비동기 작업을 연결하는 데 사용할 수 있다.

then의 return은 모든 종류의 데이터를 반환할 수 있고 자동으로 프로미스로 변환되어 감싸진다.

프로미스 체이닝이 가장 중요한 점은 단계별로 시행된다는 것이다. 하나의 then이 종료되야 다음 단계에 도달한다.


3. 프로미스 오류 처리하기
프로미스 상태 => fail state => 보류가 아니라 실패 
fail state는 두 번쨰 인자를 받아서 처리한다. (then으로 전달하는 두 번쨰 함수로 처리한다)

위처럼 사용해도 되지만 체이닝을 이용할 수 도 있다 => catch 메서드를 사용
catch는 then의 두 번쨰 인자를 전달하는 것과 동일하다.

=> 두 가지 방법이 있는 것이다.

프로미스 체인의 catch 블록 이전 혹은 두 번쨰 인자로 추가한 위치 이전에 발생하는 모든 오류나 거부를 잡아내도록 
작동한다.

then().then().then().catch()의 원리
1번쨰 then()에서 오류나 거절이 되면 2,3번쨰 then()을 실행하지 않고 catch블록이나 then의 두번쨰 인자를 찾는다.
즉, then()의 오류나 거절은 catch나 then의 두 번쨰 인자를 찾는 로직인 것이다.

then().then().catch().then()
=> catch는 return로직이 아니다. 첫 번째 then()이 실패하면 두 번쨰 then()은 건너뛰지만 3번쨰에서 처리 오류를 처리했기 떄문에 4번쟤 then()은 실행된다.

catch 블록은 무조건 반환한다. => 명시적으로 쓰지 않았다면 undefined가 반환된다.


4. Promise Status
Pending => 프로미스가 작동중이며 then()이나 catch()가 실행되지 않는다.
Resolve => 프로미스가 해결되어서 then()이 실행된다.
Reject => 프로미스가 거절되어 catch나 then()의 두 번쨰 인자가 실행된다.

catch()나 then() 블록 다음에 또 다른 then() 블록이 존재하면 프로미스가 pending모드로 다시 돌아간다.
(then과 catch는 항상 새로운 프로미스를 반환한다.)
더 이상 then() 블록이 남아있지 않은 경우에만 최종 모드 Settled에 들어간다.

Settled가 되면 특수 블록인 finally()로 최종정리 작업을 수행할 수 있다. 성공하든 실패하든 무조건 실행하는 코드이다.


5. 비동기 처리 Reveiw
비동기로 처리하는 함수들이 존재한다. => setTimeout같은 타이머들이나 Ajax, DOM은 콜백함수를 받아서 처리한다.


Review
1. 비동기 처리를 할 떄 비의도적인 함수 호출로 인해 예기치 않은 오류가 발생할 수 있음으로 원하는 부분에서 동기적으로, 순차적으로 처리할 필요가 존재한다.
2. 콜백함수안에 콜백함수를 넣으면 최종 외부함수는 비동기이지만 내부 함수들은 동기처리이다.
3. JS 엔진은 비동기 함수가 존재하지 않는다.
4. 함수 실행 로직은 외부함수 - 다음 내부 함수 - 다음 내부 함수 순서이다. => 비동기 함수를 이렇게 실행하면 동기처럼 작동한다.
4. Promise의 반환값은 promise이다.
5. Promise.resolve() => 형변환/ String.
















































