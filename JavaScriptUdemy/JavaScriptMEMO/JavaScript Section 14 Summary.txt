웹 페이지의 사용자와 상호작용하기 위해 만든 코드 => 이벤트
이벤트를 사용함으로써 이용자의 정보나 선택사항을 받아들이고 이에 해당하는 웹 페이지 변경 및 정보 반환

이벤트가 트리거 되었을 떄 함수가 실행되는데 이를 이벤트 핸들러라고 칭한다.

이벤트를 만드는 3가지 방법
1. HTML에서 속성으로 onclick, onmouseenter, ...ect을 주는 방법
=> html 코드내에서 js코드 있기에 비효율적이다.
2. JavaScript에서 DOM객체의 프로퍼티의 이벤트 트리거를 붙이고 함수를 할당하는 방법
=> 이 방법은 하나의 함수만 가질수 밖에 없음으로 비효율적이다. 
3. DOM에 addEventListener()를 주는 방법
=> 첫 번쨰 인자는 이벤트 트리거를 문자열로 받는다. 이떄 js프로퍼티나 HTML 속성에서는 on이 붙지만 리스너는 붙지 않는다. 두 번쨰 인자로는 함수를 받는다. 세 번쨰 인자는 캡쳐링의 여부이다. 기본적으로는 false이다.

이벤트 리스너의 이벤트 핸들러 삭제 방법
removeListener()/ 첫 번쨰 인자로 삭제할 이벤트 , 두 번쨰 인자로 삭제할 함수를 넣는다. 두 번쨰 인자는 같은 주소값을 가져야 한다.

이벤트 객체는 브라우저에서 자동으로 생성되고 이벤트 핸들러가 작동될 떄 자동으로 이벤트 핸들러에 할당된다.
=> div.addEventListener('click', (event)=>{
   event.preventDefault();
   console.log(event);
}) => 이 행위가 가능한 이유이다.

event.target => 이벤트가 발생하는 영역을 의미한다. 이를 통해서 get이나 set를 사용할 수 있다.

preventDefault() => 각 이벤트들은 대체로 기본동작이 존재한다. form의 이벤트가 submit이라면 서버에 데이터를 보내는 것이 기본동작이다. 서버에 데이터를 보내면 새로고침을 한다. 이벤트 핸들러가 작동해도 무의미하다는 것이다.
이러한 기본동작을 막고 개발자의 이벤트 핸들러를 사용하기 위해서는 preventDefault()를 사용해야 한다.


캡쳐링, 버블링
캡쳐링은 기본적으로 무시된다. 그러나 리스너의 세 번쨰 인자에 true를 주면 버블링보다 우선순위를 갖는다.
버블링은 자식요소의 이벤트 핸들러가 작동되면 부모의 이벤트 핸들러도 작동하고 더 이상 찾을 수 없는 조상요소까지 이벤트 핸들러를 작동시키게 한다. => 이러한 행위를 전파라고 한다. 이를 막을려면 stopProgagtion()을 사용하면 된다. 모든 이벤트들이 버블링되는 것은 아니다. mouseenter, mousemove 같은 경우는 안된다. event.bubbles 프로퍼티를 확인하면 알 수 있다. 캡쳐링은 한 요소에서 실행되면 최상위 조상부터 시작해 아래로 전파하는 것을 의미한다.

Event delegation
이벤트 리스너가 많으면 메모리 공간 부족이 발생할 수 있다. => 이벤트 위임을 사용하자.
부모 DOM에 이벤트 리스너가 존재하면 각 자식들은 이벤트가 트리거 될 떄 부모의 핸들러를 호출시킨다. 이후 자식 요소에서만 그 이벤트 핸들러를 사용한다.
Event.target => 현재 이벤트가 트리거될 떄 함수를 발동시킬 지점을 의미한다.


















