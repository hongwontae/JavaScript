1. 보안 허점 개요 & 코드에 데이터 노출하기

Security Details In your code
스크립트가 브라우저에 의해 다운되고 실행된다. 페이지 방문자에게 JS 코드를 노출시킬 수 밖에 없다는 것이다. 그렇기에 Client 코드에는 보안이나 기밀사안 데이터를 넣어서는 안된다. (JS에 데이터베이스 정보가 있다면 공격당할 위험이 존재한다.)
브라우저에 의해 실행된 JS 코드는 source 탭에서 쉽게 볼 수 있기 때문에 악용될 만한 정보를 JS측에서 갖고 있으면 	보안상의 위험이 항시 존재한다.


2. 교차-사이트 스크립트 공격 (XSS)

Cross-Site Scripting Attakcs
해로운 JS 코드를 애플리케이션에 삽입하고 실행시키는 공격이다.

URL에 innerHTML를 사용해서 만들고 반환하는 코드는 사용자가 URL를 악의적으로 바꿀 경우 의도치 않은 상황이 벌어진다. (최신 브라우저는 InnerHTML으로 생긴 결과값인 script 태그를 실행하지 않는다.)
하지만 html 코드를 넣으면 실행된다. <img src"ll" onerror="alert('Hi there')"> => 의도치 않은 동작을 허용하게 됐다. => innerHTML의 허점이다. 그렇기 때문에 textContent를 많이 사용한다.

사용자가 만든 데이터가 안전한지, 실행할 수 있는 스크립트가 없는지 확인할 필요가 있다.
=> sanitize-html 패키지를 사용한다. 이 패키지는 텍스트를 검사하고 원하지 않은 태그를 삭제할 떄 도움이 된다.
=> 유효하지 않는 코드가 실행되지 않는다.
=> 이 패키지의 코드를 실행하면 안전한 HTML만을 렌더링한다.

가장 좋은 방법은 DB에 저장하기 전에 서버단에서 보안 검사, 유효성 검사를 하는 것이 제일 좋다.


3. 제 3자 라이브러리 & XSS
textContent를 사용하거나 sanitizeHtml를 사용해서 브라우저 측 보안 검사를 할지라도 취약점은 존재한다.
구글 맵 API 스크립트를 빌려와 사용자의 머신에서 실행한다. 어떤 라이브러리도 앱이 실행될 떄 코드를 실행한다.
=> 구글의 경우 신뢰가는 라이브러리이지만 신뢰성이 떨어지는 라이브러리는 의심해봐야 한다.


4. 교차 사이트 요청 위조 (CSRF)

Cross-Site Request Forgery
링크를 클릭하여 준비된 페이지로 유도하는 공격이다. 해당 페이지에서 로컬 쿠키를 악용하여 일반적으로 통신하는 페이지에 요청을 보낸다. 준비된 페이지(신뢰하는 페이지처럼 속임)에서 백엔드 서버에 요청을 보낸다. => 온라인 뱅킹 백엔드의 정보를 뺴간다.

워조 사이트에서 악용할 목적으로 서버에 요청을 하고 서버는 이를 알아차리지 못하고 정보를 보낸다.
올바른 쿠키와 올바른 세션 ID를 갖고 있기 때문이다. => 강탈당함
=> 교차 사이트 요청 위조의 예


5. 교차 출저 리소스 공유 (CORS)

Cross Origin Resource Sharing

어떤 사이트를 접속할 떄 url이라는 문자열을 통해 접근한다.
Protocol(Scheme) : http, https
Host : 사이트 도메인
Port : 포트 번호
Path : 사이트 내부 경로
Query string : 요청의 key와 value값
Fragment : 해시 태크

origin => protocool, Host, Port를 합친 URL를 의미한다.

Same Origin => 동일한 출저에 대한 정책을 의미한다. 이 SOP 정책은 동일한 출처에서만 리소스를 공유할 수 있다.
동일 출처(Same-Origin) 서버에 있는 리소스는 자유로이 가져올수 있지만, 다른 출처(Cross-Origin) 서버에 있는 이미지나 유튜브 영상 같은 리소스는 상호작용이 불가능하다는 말이다.
=> 악의적인 상황을 막기 위해 SOP 정책을 통해 사전에 방지한다.

Origin(출처)의 동일함은 Protocool, Host, Port 3가지가 동일하다면 동일 출저로 판단한다.

이러한 출저 차단은 로직은 브라우저가 갖고 있고 브라우저가 실행한다.

=> 무조건 막으면 안되기 때문에 예외 조항이 존재한다. CORS를 정책을 지킨 리소스 요청이라고 부른다.
=> SOP 정책을 위반해도 CORS 정책을 따르면 다른 출처의 리소스라도 허용한다.

브라우저의 CORS 기본 동작
1. 클라이언트에서 HTTP요청의 헤더에 Origin을 담아 전달
2. 서버는 응답헤더에 Access-Control-Allow-Origin을 담아 클라이언트로 전달한다.
3. 클라이언트에서 Origin과 서버가 보내준 Access-Control-Allow-Origin을 비교한다.

CORS 해결책은 서버의 허용이 필요하다는 것이다.
서버에서 Access-Control-Allow-Origin 헤더에 허용할 출처를 기재해서 클라이언트에 응답하면 되는 것이다.
(클라이언트에서 JS를 통해 Origin 헤더값을 위조해서 주어도 브라우저가 감지하여 막는다.)













































