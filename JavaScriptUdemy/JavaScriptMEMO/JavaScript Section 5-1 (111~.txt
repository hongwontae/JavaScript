1. var/let/const 블록 범위
var와 let은 변동 가능한 변수를 생성하고 const는 상수 변수를 생성한다.

let과 const는 Block Scope이고 var는 함수, 전역 Scope이다.
(var는 if문이나 for문 같이 가로()안에 있을 떄는 전역 Scope이고 중괄호{}안에 있을 떄는 함수 Scope가 된다.)
(var는 변수의 중복선언이 가능하다. var name='1' var name='2' console.log(name) =>'2')

let과 const를 사용해 중괄호 안에 변수를 생성하면 변수는 해당 블록(중괄호)으로 스코프가 지정되어 해당 블록에서만 사용가능하다. 블록 밖에서는 사용불가능하다.

현재 자바스크립트에서 let과 const만 사용한다.

let과 const로 변수를 재 선언하면 오류 발생/ let은 재할당 가능, const는 불가능


2. hoising
var의 경우 
ex) console.log(userName) 
    var userName = 'Max'

=> var userName;
   consoel.log(userName);
   userName = 'Max'
=> 이런 식으로 JS엔진과 브라우저가 작동한다.


3. 엄격모드 & 읽기 좋은 모드
userName = 'Max' console.log(userName) => 'Max'
=> JS는 관대한 언어라서 키워드를 누락한 했다 가정하여 var userName = 'Max'라고 판단한다.
var undefined = 5 => 이 자체로 오류가 발생해야 되지만 오류가 발생하지 않는다.

이러한 관대한 코드를 방지하고 싶다면 "use strict"를 js코드에 작성하면 된다. 단지 문자열이다.


4. JS가 돌아가는 원리
HTML안에 Script가 import되어 있다. 브라우저는 script를 실행해야 한다.

1. 분석 : 브라우저가 js코드를 읽어 들어서 로딩하는 작업이다.
2. 실행 : 코드가 영향력을 발휘하는 단계
=> 이 떄 브라우저는 JS엔진을 이용하게 된다.(크롬은 V8이라고 부른다.) 이 분석과 실행을 맡는 부분은 두 부분으로 나뉜다. 인터프리터와 컴파일러(jit)이다. 

스크립트를 로딩하고 실행하는 작업을 인터프리터가 수행한다. 스크립트를 로드하고 읽어서 실행하기 좀 더 쉬운 바이트코드로 변환한 다음 스크립트의 실행을 시작한다. 인터프리터가 스크립트를 실행할 떄 최적화된 방식으로 한 줄씩 실행한다. => 빠른 방식은 아니다. 높은 성능을 위해서는 단순하게 코드를 해석해서 실행하는데 그치는 것이 아니라 머신에 코드를 컴파일한 다음 운영체제에 전달하는 것을 목적으로 해야 한다. JS코드를 머신 코드를 변환하는 것이 바로 컴파일러의 작업이다. 

인터프리터가 읽고 스크립트의 실행을 시작할 뿐만 아니라 바이트코드를 컴파일러로 전달한다.
인터프리터가 스크립트를 실행하는 동안 컴파일러는 스크립트를 머신 코드로 컴파일하기 시작한다.
(JIT 컴파일러는 코드를 읽고 실행 중에 컴파일을 시작하고 동시에 컴파일 된 코드를 실행한다.)

이 후 머신 코드는 컴퓨터로 전달되어서 실행 단계로 접어든다. 이전 코드와 같은 코드가 재 실행되었을 경우 재컴파일링을 거치지 않고 컴파일된 코드를 다시 사용한다.


5. Detail JS Engine
JS는 단일 스레드이다. 한 번에 하나의 함수만을 호출하고 다른 함수는 그 함수의 응답을 기다린다.
함수의 순서를 보장하고 모든 함수가 어떤 함수와 관련되었는지를 알아 볼 수 있게 해준다.
JS엔진 안에는 Heap/Stack이라고 부르는 공간이 있다.

(인터프리터와 컴파일러의 작업이 끝난 후)
Heap은 장기 메모리이고 Stack은 단기 메모리이다.

Heap에는 스크립트 파일의 함수들이 저장되어 있다. 함수가 호출되면 Stack으로 가서 저장된다. 이후 함수안에 함수가 먼저 위로 쌓이고 그 함수는 실행되면 Stack에서 사라진다. 마지막 함수가 실행되면 이 또한 사라진다. 이후 전체 스크립트 파일인 익명함수가 사라지고 Stack공간은 비워있게 된다.


6. 원시값 vs 참조값
자료형은 두 가지로 나뉠 수 있다. 원시값과 참조값이다.

원시값은 대체로 Stack공간에 저장된다./ .을 사용하면 속성에 접근한다는 뜻이다. 만약 원시값에 .를 사용하면 일시적으로 객체로 변하여 const name = 'hwt' name.length =>3를 사용할 수 있다는 뜻이다.
원시값의 경우에는 실제 값을 stack에 저장한다.
원시값 => string, number, boolean, undefined, symbol, null

참조값은 대체로 Heap공간에 저장된다. 참조값은 Heap 공간에 그 객체의 주소값을 저장한다. 값은 브라우저의 메모리 어딘가에 저장된다. 메모리(참조변수의 값)/ Heap(주소값) => Heap이 실제이다.
참조값에 할당 연산자를 사용한다는 것은 주소값을 바꾸겠다는 의미이다.
참조값 => 객체, 배열, 함수






























