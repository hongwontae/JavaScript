1. 분산 연산자(전개 연산자) (Spread Operator)
전개 연산자는 배열의 모든 요소를 꺼내 개별 요소의 리스트로 변환한다.
=> const b1 = [1,2,3,4,5]/ const b2 = ...b1 => 1,2,3,4,5
=> 요소의 리스로 반환된다.
=> 요소의 리스트란 ,로 구분된 값의 모음을 뜻한다.

전개 연산자 = ...
const a1 = [1,2,3,4,5]/ const a2= [...a1]
=> a2의 배열안에 a1의 값을 넣어준다. a2의 배열은 새로운 참조값을 가진 배열이다.

배열에 있는 객체를 복사할 떄 새로운 배열을 만들었지만 새로운 객체는 만들지 않았다면 객체를 편집할 경우 원본배열과 복사된 배열 둘 다 상호작용을 한다.

=> 즉, 객체가 있는 배열에 전개연산자를 사용하면 배열은 새로운 참조값을 갖지만 객체는 새로운 참조값을 갖지 않는다.

-- forEach나 map이나 filter에서 배열의 객체값을 다룰 떄 기존의 값을 복사하여 새로운 객체를 만들고 싶다면
   ex) const copiedPersons = persons.map(person => ({
  name: person.name,
  age: person.age
}));
=> person.name를 값에 줘야한다. 고급반복의 첫 번쨰 인자는 element 각 요소인데 그냥 이렇게 하는거 같다.


2. 배열 구조 분해 이해하기
const nameData = ['Max', 'Schwarz'];
// const firstName = nameData[0];
// const lastName = nameData[1];
=> 이러한 방식을 사용해도 좋지만 조금 빠른 방법이 존재한다.

const [name1,name2] = nameData;
console.log(name1,name2)
=> const/let/var 앞에 []를 작성하고 = 데이터를 꺼낼 배열
=> JS가 순서에 맞게 [] 변수명으로 배열값을 저장한다.

배열의 전부나 나머지를 모두 꺼내서 변수에 넣고 싶은 경우
const nameData = ['Max', 'Schwarz', 'Mr', 30];
const [ firstName, lastName, ...otherInformation ] = nameData;
... => Rest연산자라고 부른다. 배열에 남아있는 모든 요소를 수집하여 새로운 변수에 저장한다.
=> firstName가 lastName에 값이 할당되고 남은 값들을 ...otherInformation에 배열 형태로 담는 로직이다.


3. Maps & Sets
JS에서는 3개의 주요 데이터 구조가 존재한다. (array, sets, maps)
Array => 배열 메서드 사용가능, 요소의 순서가 보장된다. 중복를 허용한다. 인덱스를 사용한다.
Sets => 데이터 구조를 뜻하며, 배열 메서드가 아닌 sets 메서드를 사용한다. Array.from 메서드를 통해 이터러블 set를 배열로 변환할 수 있다. 요소의 순서를 보장하지 않는다. 중복을 허용하지 않는다. 인덱스 기반으로 접근하지 않는다.
Maps => 키-값으로 데이터를 저장한다. maps은 키로 배열이나 또 다른 객체를 가질 수 있다. (일반 객체는 불가능)
maps 메서드를 사용한다. 순서를 보장한다. 중복 키는 허용하지 않는다. 값의 중복은 허용된다. 키로 값에 접근한다.











































