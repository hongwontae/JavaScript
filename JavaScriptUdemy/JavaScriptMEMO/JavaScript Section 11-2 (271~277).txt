1. Class and ProtoType
[[ProtoType]] => 모든 객체가 가지고 있고 프로토타입 체인이 발생하는 곳이다. __proto__로 접근할 수 있다.
prototype => 생성자 함수가 가지고 있는 프로퍼티이다. 생성자 함수로 객체를 만들면 그 객체의 [[protoType]]이 된다.

일반적인 필드는 생성된 객체의 프로퍼티로 추가된다.
constructor에서 항상 super()를 먼저 호출해야 한다.

2. Class and 생성자안의 메서드
클래스내의 메서드는 객체 내부의 존재하지 않고 [[protoType]]에 존재한다.
reason => 클래스내의 메서드는 로직은 바뀌지 않는다. 이러한 특성을 때문에 JS가 최적화를 한다. 프로토타입에 메서드를 추가함으로써 새 person 객체를 만들 떄마다 동일한 프로토타입을 가지게 된다. => 성능 향상

프로토타입에 추가하지 않고 일반 객체의 메서드로 존재하게 하고 싶다면
1. constructor에서 메서드를 추가한다.
2. 일반함수나 화살표 함수를 축약하지 않고 생성한다.
=> 1,2 방식에서 할당연산자를 사용하여 만들어야 한다.


3. 프로토타입 setting/getting
기존에 존재하는 객체에 대한 프로토타입을 확인이나 변경을 원한다면?
Object.getPrototypeOf(객체명) => 인자로 받은 객체의 프로토타입을 확인하는 메서드
Object.setPrototypeOf(객체명, 프로토타입) => 두 개의 인자를 받는데 하나는 프로토타입을 설정할 객체, 두 번쨰는 사용할 프로토타입이다.

Object.create() 
=> 새로운 객체를 생성하고 기본적으로 객체 리터럴 표기법과 비슷하다.
=> 두 개의 매개변수를 받는다. 첫 번쨰 매개변수는 프로토타입으로 설정된다. 두 번쨰 매개변수는 메서드를 통해 만들 객체의 프로퍼티를 설정하는 구문이다. (defineProperty);


4. 마무리
생성자 함수 
=> new로 작동한다. but 없어도 작동은 한다.
=> 모든 프로퍼티나 메서드가 열거가능하다.
=> 기본적으로 엄격모드가 아니다.

클래스
=> new로 작동한다. 없으면 객체 생성이 불가능하다.
=> 메서드들은 열거가 불가능하다.
=> 기본적으로 엄격모드이다.

클래스 내의 일반적인 메서드는 class의 prototype에 저장되고 클래스 필드는 인스턴스 객체에 저장된다.

extends를 한 자식 클래스의 this는 부모 클래스의 메서드를 사용하더라도 자식 필드를 가르킨다.
(부모 클래스에서 메서드를 가져와서 박아넣는다라고 생각하면 된다.)






















