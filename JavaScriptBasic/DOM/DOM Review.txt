1. 순서
서버로부터 HTML를 받아오면 숫자로된 2진법으로 데이터가 넘어온것을 meta charset UTF-8 같은 것을 보고 문자열로 변환하여 해석하고 실행한다. 실행할 떄의 첫 동작은 HTML DOM를 생성하는 것이다. 근데 이 떄 JS script나 CSS style를 만나면 DOM 생성을 멈추고 다운과 실행의 제어권을 해당 엔진에 넘겨준다.
JS, CSS 엔진은 제어권을 받으면 다운받고 실행한다. 이 후 HTML DOM를 생성하는 엔진에 제어권을 넘겨준다.

모두 만들고나면 통상적으로 JS의 DOM API를 통해 HTML의 DOM에 접근하고 제어할 수 있다.
=> DOM를 만들다가 script 태그를 만나면 js를 실행하는데 이 떄 DOM API를 사용해서 접근한다면 DOM를 만들지도 않았는데 접근하는 것이라서 null이 반환된다.
=> 이런 문제점을 개선하려고 script 태그를 밑에 둔다. 하지만 HTML 파일의 용량이 크다면 script 태그의 도달 시간이 느려져서 효율성에 문제가 생길 수 있다.
=> 또 다른 문제점을 개선하기 위해 defer를 사용한다. defer는 HTML이 script 태그를 만나도 제어권을 넘기지 않고 HTML를 실행하여 DOM를 만든다. 다만 script 태그를 만나면 다운로드만 할 뿐이다. HTML의 실행이 종료되면 script 태그에 제어권이 넘겨져서 실행된다. => 병렬적으로 수행하지만 동기적인 처리이다.


2.  DOM?
DOM은 document Object Model이라고 하며 HTML이 로드되고 실행될 떄 만들어지는 객체이다. DOM은 각 노드로 구성되어 있다. 노드안에는 요소 노드, 텍스트 노드, 속성 노드 등이 존재한다.
DOM은 BOM에 속해있는 것이 아니다. window 아래에  DOM, BOM, JS(array, Data, Math)가 존재하는 것이다.


3. BOM?
자바스크립트가 브라우저와 소통하기 위해 만들어진 모델이다. 표준은 아니다. JS와 Browser 상호작용에 관한 프로퍼티나 메서드를 통칭하여 BOM이라고 부른다.
Navigator, History, Screen 등...


4. DOM QUERY
document.querySelector() => 인자에 css, id, tagName를 넣어서 해당 DOM에 접근할 수 있다. 인자에는 문자열 타입을 넣어야하고 css, id 규칙를 지켜야 한다. 만약 일치하는 여러 개가 존재할 경우
처음으로 일치되는 것을 가져온다.
document.querySelectorAll() => 위의 로직과 같지만 유사배열형태 nodeList로 해당되는 것을 모조리 가져온다. 논 라이브 배열이다.
=> 이 메서드들은 일치하는게 없다면 null를 반환한다.

getElementById() => 인자에 문자열 형태로 일치하는 첫 번쨰 id에 해당하는 DOM를 가져온다. 
getElementByClassName() => 인자에 문자열 형태로 일치하는 css의 DOM를 HTMLCollection으로 모두 가져온다. 라이브 배열이다.
getElementByTagName() => 인자에 문자열 형태로 일치하는 tagName의 DOM를 모두 가져온다. HTMLCollectio으로 모두 가져온다. 라이브 배열이다.
=> 규칙X

=> 이렇게 가져온 DOM은 각자의 데이터를 담고 있는 객체이다. 프로퍼티나 메서드가 존재한다.


5. 



































