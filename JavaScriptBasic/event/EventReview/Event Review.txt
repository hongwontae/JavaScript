1. Event는 scrit에 defer가 걸려있어야 제대로 작동한다.

2. 렌더링 => HTML,Css,JS로 작성된 문서를 파싱하여 브라우저에 시각적으로 출력하는 것을 의미한다.

3. 파싱(Parsing) => 프로그래밍 언어의 문법에 맞게 작성된 문서를 읽어 들여 실행하기 위해 텍스트 문서의 문자열을 토큰으로 분해하고, 토큰에 문법적 의미와 구조를 반영하여 트리 구조의 자료구조인 파스 트리(parse tree/syntax tree)를 생성하는 일련의 과정 

4. 브라우저 렌더링 과정
1. 서버로부터 자원을 요청한 뒤 응답받기
2. HTML 파싱 후 DOM 생성하기
3. CSS 파싱 후 CSSOM 생성하기
4. 렌더 트리 생성하기
5. JS 파싱 후 AST(추상 구문 트리) 생성하기
6. 렌더 트리를 통해 HTML을 브라우저에 레이아웃 후 페인팅

5. 과정 요약
1. 서버로부터 자원을 전달받는다.  


2. 받은 HTML은 바이트 형태로 전달되어 받게되고, 이후 HTML 인코딩 방식에 따라 문자열로 변환된다. 문자열로 변환된 HTML은 토큰(문법적 의미를 갖는 코드의 최소 단위)으로 분해된다. 토큰으로 분해 된 HTML은 각각 노드 객체로 변환되여, 각각의 노드 객체가 부모-자식 관계를 형성하며 트리 형태의 자료구조인 DOM을 형성한다.

DOM => HTML 문서를 파싱한 자료구조 형태의 결과물이다.

DOM은 HTML의 구조 및 정보뿐만 아니라 HTML 요소를 제어할 수 있는 DOM API를 제공한다.


3. CSS 또한 파싱 과정이 바이트 ➡️ 문자열 ➡️ 토큰 ➡️ 노드로 이루어진다. 각각의 노드는 부모-자식 관계를 형성하며 트리 형태의 자료구조인 CSSOM을 형성한다. HTML 파싱 중, CSS를 의미하는 link 태그나 style 태그를 만날 경우 블로킹되어 CSSOM 생성으로 넘어간다. CSSOM 생성이 마무리되면, 블로킹 된 시점부터 다시 HTML 파싱을 진행한다.


4. 렌더 트리란? 렌더링에 필요한 트리 자료 구조이다. DOM과 CSSOM으로 이루어져 있다. 화면에 렌더링되는 노드만으로 구성된다. 화면에 렌더링되지 않는 display: none이나 meta 태그 등은 렌더 트리를 구성하지 않는다. 렌더트리는 HTML 요소의 레이아웃(위치와 크기)을 계산하는데 사용되거나 화면에 픽셀을 렌더링하는 페인팅 처리에 쓰인다.

브라우저 렌더링이 반복되는 경우
1. 자바스크립트에 의한 노드 추가 또는 삭제될 때 (ex. Element.insertAdjacentHTML())
2. 브라우저 창 리사이징에 의한 뷰포트(현재 화면에 보여지고 있는 다각형(보통 직사각형)의 영역) 크기가 변경될 때
3. HTML 요소의 레이아웃에 변경을 발생시키는 width, height 등의 스타일이 변경되었을 때

리렌더링은 성능에 악영향을 준다.


5. AST란? 추상 구문 트리를 말하는 것이며, 이를 기반으로 인터프리터가 바이트코드(가상 머신이 이해할 수 있는 중간 레벨의 코드)를 생성한다. HTML 파싱 중, JS를 의미하는 script 태그를 만나게 되면 블로킹되어 제어권을 JS엔진에게 넘겨주어 JS 파싱으로 넘어간다. 파싱과 실행이 종료되면 HTML 파싱이 종료된 시점부터 다시 시작해서 DOM를 만든다.

AST 생성 과정
1. JS코드는 각각의 의미를 갖는 토큰으로 분해된다.
2. 각 토큰은 서로 결합하여 AST를 형성한다.
3. AST는 바이트코드로 변환되어 인터프리터가 실행한다.


6. JS로 DOM API를 사용해서 DOM이나 CCSDOM를 변경한 경우 DOM이나 CSSOM이 변경된다. 변경된 DOM과 CSSOM은 다시 렌더 트리로 결합되며 리렌더링 되는데, 이를 리플로우(reflow, 레이아웃 계산을 다시 해주는 것)와 리페인트(repaint, 재결합된 렌더 트리를 기반으로 다시 페인트 하는 것)라고 한다.


7. 위에서 설명했다시피, HTML 파싱은 script 태그를 만나면 블로킹되어 렌더링 엔진에서 JS엔진에게 제어권을 넘겨주게 된다. 스크립트는 동기적 파싱(위에서 아래로 파싱)이 이루어지기 때문에, HTML 파싱이 script 태그의 위치에 따라 지연될 수 있다. 만약 JS 코드가 HTML 노드를 생성할 경우, HTML 파싱이 완료되어있어야 한다.
👉 따라서 script 태그는 되도록이면 body 태그 맨 아래에 위치하는 편이 좋다.

사용자가 웹 브라우저에 접근하면 서버로부터 데이터를 가져온다. => 처음엔 HTML 파싱하여 DOM를 생성하려고 한다. 그러다가 style, script 태그를 만나면 DOM 생성을 중단하고 css, js를 파싱하여 실행한다. css는 cssDom를 만들고 js는 ast를 만든다. 이후 dom+css로 렌더 트리를 생성한다. 
=> 이 과정은 construction이라고 한다.

render Tree에 있는 node를 배치한다.(layout) => render Tree에 있는 node의 Ul를 그린다.(paint)
=> render Tree에 있는 node를 순서대로 구성한다 => 웹 사용자에게 반환한다.
=> 이 과정은 operation이라고 한다.


5. defer and async
defer는 HTML 파싱하여 DOM를 만들기 전까지 JS을 파싱만 한다. 이후 DOM이 만들어지면 JS를 실행한다.
만약 script가 여러개라면 다운은 작은 스크립트가 먼저 될지라도 동기적으로 실행된다.

async는 HTML과 완전히 독립적으로 동작한다. 또한 async는 스크립트 파일이 여러개라도 먼저 파싱된 스크립트를 먼저 실행한다.


6. 이벤트 핸들러 등록 방법
인라인 방식 => html의 속성

프로퍼티 방식 => dom에 이벤트 프로퍼티를 사용한다. 하나의 이벤트 핸들러만 적용가능하다. 이미 적용되어 있는 이벤트 핸들러에 다른 핸들러를 주면 오버라이딩한다.

addEventListener 방식 => addEventListener도 DOM의 프로퍼티이다.
dom.addEventListener('trigger',function, [capturing])
=> 하나 이상의 핸들러를 가질 수 있다. 캡쳐링과 버블링을 지원한다. 


7. 이벤트 this
인라인 => this는 window를 바라본다.
프로퍼티 and 이벤트 리스너 => this는 currentTarget를 바라본다. 이벤트 바인딩된 요소를 의미한다.


8. Event 객체
이벤트 객체는 이벤트가 발생하면 이벤트 핸들러의 매개변수에 전달된다. 이벤트에 관한 유용한 프로퍼티를 가지고 있다.

Event.target => 이벤트를 발생시킨 요소를 가리킨다.
Event.currentTarget => 이벤트 바인딩된 요소를 가리킨다. 이벤트 핸들러의 this === currentTarget
Event.type => 발생한 이벤트의 종류를 나타내는 문자열을 반환한다. click, submit...
Event.cancelable => 요소의 기본동작을 취소시킬 수 있는지 여부(true, false)를 나타낸다.
Event.eventPhase => 이벤트 흐름 상에서 어느 단계 있는지를 반환한다.
(0/이벤트 없음, 1/캡쳐링단계, 2/타깃, 3/버블링단계)


9. PreventDefault();
=> 이벤트의 기본동작을 막는 메서드이다. Form의 button의 submit 이벤트의 기본동작은 서버에 데이터를 전송하는 것이다. 서버에 데이터를 전송함으로 새로고침을 하는데 preventDefault()로 이를 막을 수 있다.


10. 캡쳐링과 버블링, stopProgagation();
버블링 => 한 요소에서 이벤트가 발생하면 부모 요소의 이벤트 핸들러가 동작하고 조상요소의 핸들러가 동작하고 최상위 단계까지 가는 행위를 일컫는다.
캡쳐링 => 최상위 조상부터 시작해서 하위로 전파되는 행위

stopProgagation를 사용하면 버블링과 캡쳐링을 막는다. 캡쳐링이 버블링보다 우선순위를 갖는다.
=> 캡쳐링을 의도적으로 실행하기 위해서는 addEventListener에 3번째 인자에 true를 부여한다.
모든 요소의 기본동작이 버블링인것은 아니다. event.bubbles의 객체를 확인하면 이 이벤트의 버블링이 있는지 없는지 Boolean값으로 알 수 있다.


11. Event Delegation(이벤트 위임)
각각의 요소에 이벤트를 걸지않고 상위에서 이벤트를 제어하는 방식을 말한다. => 버블링을 이용한 것이다.

























