ES6에서 추가된 Class 문법은 JS를 객체지향적으로 표현하기 위해 추가된 문법이다.
이전에는 prototype 체이닝를 통해 객체지향처럼 사용했다.
=> Class 문법은 생김새만 클래스 구조이고, 엔진 내부적으로 프로토타입으로 작동된다.

console.log,dir()
=> 인자에 인스턴스 객체를 넣으면 왼쪽에 뜨는 것은 인스턴스를 만든 클래스나 생성자 함수 이름이 들어간다.

class 내부의 this
=> 생성된 인스턴스 객체를 가르키고 있다.
(class 내부의 this라 할지라도 이벤트 핸들러의 this는 e.currentTarget를 보고 있다.)
(이 떄도 마찬가지로 화살표 함수의 this 외부 참조를 이용하면 this는 생성된 인스턴스를 가르키고 있다.)

new 로직
=> 빈 객체를 할당한다. {}
=> {}에 this를 할당한다. {} = this
=> this의 프로퍼티들은 객체에 할당한 후 반환한다.
=> new 로직이 실행되면 this는 인스턴스에 객체를 가르키고 있다. => class 내부의 this는 인스턴스 객체를 가르키고 있다.

constructor
인스턴스를 생성하고 클래스 필드를 초기화하기 위한 특수한 메서드이다.
constructor는 클래스 안에 한 개만 존재할 수 있다. 2개 이상 있을 경우 Syntax Error가 발생한다.
컨스트럭터에서 각 객체에 할당할 프로퍼티들은 this로 정의해야 한다. => 그렇지 않으면 오류가 발생한다.

Class 특징
1. 일반적으로 constructor 외부에서 메서드가 아닌 프로퍼티가 정의되더라도 인스턴스의 객체 포함된다.
=> class Person{
    constructor(){
        ....
    }
    height = 10000;
} // height = 10000도 마찬가지로 인스턴스 객체에 포함된다.

2. 메서드 내부에서 this.프로퍼티가 정의되면 함수 호출 시점에 관계없이 인스턴스 객체에 포함된다.
class Person{
    constructor(){
        this.name = name;
    }
    height = 1000;
    birth(){
        this.birthday = '1998/02/23';
    }
}
let person = new Person();
console.log(person);
person.birth()
=> console이 먼저 오고 인스턴스 객체가 호출되어서 프로퍼티가 추가되었다.
=> 하지만 console 창에는 함수 호출로 생긴 프로퍼티가 정의되어 있다.
=> 함수 호출로 인한 프로퍼티 생성은 시점에 구애받지 않는다.

3. constructor 메서드가 아니고 완전한 함수식이 아닌 축약 메서드라면 class의[[prototype]]이다.
    그렇기 떄문에 인스턴스 객체의 [[prototype]]으로 들어간다.

4. Java는 인스턴스 변수가 존재하고 생성자를 통해 전달해야 한다. JS는 생성자의 this를 사용해서 자동 생성할 수 있다.

5. class는 항상 use strict 모드이다.


class 메서드 정의
=> 객체 메서드처럼 정의한다.


static 프로퍼티 and 메서드
정적 메서드는 클래스의 인스턴스가 아닌 클래스 이름으로 곧바로 호출되는 메서드이다.
static 키워드를 메소드 이름 앞에 붙여주면 해당 메소드는 정적 메소드가 된다.
static 키워드를 프로퍼티 이름 앞에 붙여 주면 해당 프로퍼티는 정적 메소드가 되어 곧바로 호출할 수 있다.
* 우리가 랜덤값을 얻기 위해 Math.random() 같은 메서드를 쓰듯이, 따로 new Math() 없이
 곧바로 클래스명.메서드명 으로 함수를 호출해서 사용하는 것이 바로 radom 메소드가 static으로 설정되어 있기 때문이다.


클래스 상속
​클래스 상속(class inheritance, subclassing) 기능을 통해 한 클래스의 기능을 다른 클래스에서 재사용할 수 있다.

1. extends 키워드
클래스를 다른 클래스의 하위 클래스로 만들기 위해 사용된다.
어떤 클래스 A가 다른 클래스 B를 상속받으면, 다음과 같은 일들이 가능해진다.
1. 자식 클래스 A를 통해 부모 클래스 B의 정적 메소드와 정적 속성을 사용할 수 있다.
2. 부모 클래스 B의 인스턴스 메소드와 인스턴스 속성을 자식 클래스 A의 인스턴스에서 사용할 수 있다.
3. 부모 클래스의 constructor는 상속받은 자식의 인스턴스 프로퍼티에 추가된다. => 자식의 super() 호출로 인해서..
4. static 프로퍼티는 자식 class에서 오버라이딩 할 수 없다.


2. super() and super.;
자식 클래스의 생성자 내부에서 super를 함수처럼 호출하면, 부모 클래스의 생성자가 호출된다.
정적 메소드 내부에서는 super.prop과 같이 써서 부모 클래스의 prop 정적 속성에 접근할 수 있다.
인스턴스 메소드 내부에서는 super.prop과 같이 써서 부모 클래스의 prop 인스턴스 속성에 접근할 수 있다.
super()는 자식 constructor에서 반드시 사용해야 한다. 그렇지 않으면 오류가 발생한다.
super. 키워드는 부모 메서드 => 자식 메서드/ 부모 정적 메서드 => 자식 정적 메서드로만 사용된다.
부모 메서드 => 자식 정적 메서드에서 사용이 불가능하다는 것이다.

* 부모의 costructor가 매개변수를 가진채 존재하고 자식의 constructor가 존재할 떄 
  자식에서 super()만 사용했다면 객체의 값에 해당하는 부분이 undefined가 할당된다.


prototype 구조
자식 extends 부모인 클래스를 기준으로 prototype 구조를 살펴보자
자식을 매개로 인스턴스를 만들면 해당 객체의 [[prototype]]은 자식 클래스 컨스트럭터와 축약된 메서드이다.
위의 [[prototype]]의 [[prototype]]은 부모 클래스 컨스트럭터와 축약된 메서드이다.
(obj.prototype으로 임의적으로 프로퍼티를 추가 할 수 있다.)
