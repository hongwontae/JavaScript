1. 실행 컨텍스트
정의 : 실행할 코드에 제공할 환경 정보들을 모아놓은 객체이다.

특징
1-1. 실행 컨텍스트가 활성화되는 시점에 나타나는 현상
(호이스팅, 외부 환경 정보 구성, this 값을 설정)

1-2. JS Engine은 코드를 읽기 시작하면 코드 타입에 따라 각기 다른 실행 컨텍스트를 생성한다.

1-3. 실행 컨텍스트는 3개로 분류된다.
Global Execution Context (전역 실행 컨텍스트) => 전역에 존재하는 소스코드
Functional Execution Context (함수 실행 컨텍스트) => 함수가 호출될 떄 생성된다.
Eval Function Execution Context => 빌트인 전역 함수인 eval 함수에 인수로 전달되어 실행되는 소스코드
(Eval은 거의 사용하지 않는다.)


2. Global Execution Context (전역 실행 컨텍스트)
2-1. 브라우저의 경우, window 객체, let, const 전역 변수 
2-2. Node.js경우, global 객체

3. Functional Execution Context (함수 실행 컨텍스트)
3-1. 함수가 실행될 때마다 만들어지는 실행 컨텍스트이다.
각 함수는 고유의 실행 컨텍스트를 가지며, 함수가 실행되거나 호출될때 생성된다.

4. Eval Function Execution Context
4-1. eval 함수로 실행되는 코드


5. 실행 컨텍스트 실행 시점
=> 자동으로 생성되는 전역공간과 eval을 제외하면 실행 컨텍스트가 생성되는 시점은 곧 함수를 실행하는 시점이다.


6. 소스코드의 평가와 실행
6-1. JS Engine은 소스 코드를 소스코드 평가와 소스코드 실행과정으로 나누어 처리한다.

6-2. 소스코드 평가
실행 컨텍스트를 생성한다. 
변수, 함수 등의 선언문만 먼저 실행하여 생성된 변수나 함수 식별자를 키로
실행 컨텍스트가 관리하는 스코프(렉시컬 환경의 환경 레코드)에 등록한다.

6-3. 소스코드 실행
소스코드를 순차적으로 실행한다. 즉, 런타임이 실행된다.
실행에 필요한 정보(변수, 함수의 참조)를 스코프에 검색해서 얻는다.
그리고 변수 값의 변경 등 소스코드의 실행 결과는 다시 실행 컨텍스트가 관리하는 스코프에 등록된다.


7. 실행 컨텍스트 동작과정
7-1. 실행 컨텍스트는 실행 컨텍스트 스택(콜스택) 자료구조에 저장되고 관리된다.
7-2. 콜스택 자료구조에 의해서 글로벌 컨텍스트와 함수 컨텍스트가 실행된다.
7-3. 제일 위에 있는 컨텍스트가 콜 스택의 우선 실행 제어권을 가지게 되는 것이다.


8. 실행 컨택스트와 재귀함수
8-1. 스택은 한계가 있어서 이 한계를 초과해서 실행 컨택스트가 push 되면, Maximum call stack 에러가 발생한다.
8-2. 재귀함수 => 호출된 함수가 자기 자신을 또 호출하면서 반복작업을 수행하는 함수
=> 실행 컨텍스트는 코드가 실행되는 순간의 정보들을 담고 있고 스택에 차례로 쌓인다.
=> JS는 깊이가 깊어져도 함수가 종료되거나 다음 수행할 부분을 잘 기억한다.


9. 렉시컬 환경
정의 : 전체 스크립트, 코드 블록, 호출된 함수에서 선언된 변수와 함수 정보 + 부모 환경의 렉시컬 환경 참조값을 가지고 있다.

특징
8-1. 환경 레코드 : 현재 실행중인 코드 환경의 선언된 모든 변수와 함수가 저장되는 곳
(레코드 변수 다른 값을 할당하면 레코드의 변수값이 변동된다.)
8-2. 외부 렉시컬 환경 (Outer Lexical Environment) - 외부 렉시컬 환경의 참조값 (외부 변수에 접근할 수 있게 된다)

=> 변수의 식별자 이름을 키로 저장한다.

8-3. example
ex)     
    // (A)
    let name1 = 'kwang'; // (B)
    var name2 = 'sunny';

    function test(){
        let msg = 'Hi~';
        console.log(`${msg} ${name1} ${name2}`); // (C)
        
    }
    
    test(); // (D)
=> 전체 글로벌 (스크립트)렉시컬 환경, 호출한 함수 test()의 렉시컬 환경이 존재하는 것이다.
=> 호출한 test 함수의 부모는 글로벌 렉시컬 환경이고 글로벌 렉시컬 환경의 부모는 null이다.
=> 이렇게 체인해서 올라감에도 변수를 찾지 못하면 reference 에러가 발생한다.

=> A 지점에서 console.log(name1) 혹은 console.log(name2) 실행하면?
1. 환경 레코드 떄문에 let name1의 존재는 알고 있지만 선언되기 이전에 uninitialized 라는 상태를 가지고 있어서 
이때 접근하면 에러가 발생한다.
2. var로 선언된 변수는 렉시컬 환경에 올라가자마자 undefined로 초기화가 된다.

=> 함수 선언문은 렉시컬 환경이 생성되자마자 메모리에 올라가서 순서 상관 없이 사용가능

=> *** 렉시컬 환경은 함수가 실행되는 시점이 아닌 선언된 시점의 외부 환경을 가리킨다.


10. 실행 컨텍스트의 내부 구조와 생성 단계
정의 : 실행 컨텍스트 내부에 Variable Environment, Lexical Environment, this binding가 존재한다.

10-1. 생성단계
1. 렉시컬 환경 + this 바인딩
2. 환경 레코드에 변수와 함수가 저장된다.
3. 함수 선언문 바로 메모리에 올라간다.
4. var로 선언된 변수는 undefined 가 할당되고, let, const 로 할당된 변수는 uninitialized 상태이다. 
=> 모든 변수가 생성 단계에서 렉시컬 환경에 초기화 되기 때문에 자바스크립트 엔진은 변수들의 존재를 모두 인지하게 되고, 
이것이 호이스팅(hoisting)이 발생하는 이유가 된다.

10-2. 실행 단계
1. 생성 단계에서 결정된 렉시컬 환경을 가지고 있는 상태로, 코드를 한줄씩 실행해 내려간다.
2. 변수에 값을 할당하면 렉시컬 환경의 해당 변수 값이 변경된다.


























