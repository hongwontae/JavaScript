1. 일반적인 함수 안에서의 this
일반모드일떄는 window/ 엄격모드일떄는 undefined가 반환 (전역 상태의 this)


2. 생성자 함수의 this

2-1. 모든 함수에 new를 붙이면 생성자 함수처럼 행동한다. 
=> 객체를 반환하게 된다.
=> 생성자 함수 내부에서 사용된 this는 반환된 객체를 가리키게 된다.

2-2. 생성자 함수 this Logic
1. new가 실행되면 this = {} => this에 빈 객체가 할당된다.
2. 생성자 함수 본문의 this.key = value가 실행되어 this = {name = hwt, age : 29}가 된다.
3. this를 return한다. => return this;
4. this가 반환되어 새로운 객체가 되었기 떄문에 객체 프로퍼티의 this는 생성된 객체를 가리키게 된다.


3. 메서드와 this

3-1. 메서드 => 객체 프로퍼티에 할당된 함수

3-2. this가 메서드로 호출될 떄의 Logic
메서드의 this는 호출한 객체를 가리킨다.
*** 생성자 함수 + 객체.메서드() 형식 => this는 생성된 객체를 바라본다.
*** 일반 함수 호출 => 전역을 바라본다.

3-3. 같은 함수를 공유해도 this의 값은 호출되는 시점에 어떤 객체에서 호출했냐에 따라 메서드의 this의 값이 달라진다.
=> 메서드의 this의 값은 호출 시점에 정해진다.
(렉시컬 환경이 선언 시점에 정해지는 것과 달리 this는 호출 시점이다. => 상반되는 개념)

3-4. 메서드가 호출되지 않고 다른 값으로 담기거나, 콜백함수로써 다른 함수에 전달되어 호출될 떄
=> 전역을 바라본다.

3-5. 객체의 프로퍼티의 값으로 this가 사용되었다면 global this이다.


*** 메서드의 본문 안에 this가 있다. 그러면 실행되어서 가는가? 그러면 그 this는 값이 정해진 채로 가는 것이다.
*** 그러나 포인터만 갔다면? => this의 값은 정해지지 않은 것이다.



4. this의 명시적 바인딩
메서드가 호출 x되고 변수에 담겨서 호출 + 일반 함수 호출 + 콜백함수의 포인터
=> this가 전역을 바라본다. this의 값을 고정시키고 싶을 떄?

4-1. 바인딩 메서드 (bind, call, apply)
function 또한 new Function을 통해 만들어진 객체이다. => 모든 함수의 프로토타입에 bind, call, apply가 존재한다.

1. bind
this가 설정된 function에 bind을 호출하여 인자에 값을 넘겨주면 this의 값이 고정된 함수가 반환된다.
(bind의 두 번쨰 인자부터는 인자를 자동으로 추가해주는 effect);
(두 번쨰 bind는 무시한다.)

2. call, apply
call, apply는 그 자리에서 바로 함수를 호출한다. (this는 함수를 반환한다.)



5. 이벤트 콜백과 this
5-1. html 속성값의 onClick, onPress..을 통해 이벤트 핸들러를 할당했을 떄의 this는 전역을 바라본다.
=> html 속성을 이용한 이벤트 핸들러는 일반 함수 안에서 이벤트 핸들러를 실행시켜버리기 떄문이다.

5-2. JS 프로퍼티, addEventListener의 this는 always 이벤트가 발생한 요소를 가리킨다.


6. 화살표 함수의 this
6-1. 화살표 함수는 정적 바인딩 => 함수가 선언되는 순간 코드상 바로 바깥쪽 있는 스코프의 this를 사용한다.

6-2. 함수 내부에 화살표 함수 + this가 존재하면 화살표 함수 외부의 this scope를 사용한다는 것이다.


*** console.log()로 객체가 반환되면 생성자함수이름 {key : value, key : value....} 이런 식으로 나온다.
*** 객체 리터럴로 만든 객체를 console.log()의 인자로 주면 (옆에 아무것도 없다.) {key : value..}만 나온다.
*** 일반 함수나 생성자 함수를 console.log()의 인자로 주면 문자열 형식으로 반환된다.
